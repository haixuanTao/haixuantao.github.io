<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pandas vs Rust - Haixuan Xavier Tao</title>
                

        <!-- Custom HTML head -->
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

                <link rel="icon" href="favicon.svg">
                        <link rel="shortcut icon" href="favicon.png">
                <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
                <link rel="stylesheet" href="css/print.css" media="print">
        
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
                <link rel="stylesheet" href="fonts/fonts.css">
        
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
                <link rel="stylesheet" href="custom.css">
        
            </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="about-me.html"><strong aria-hidden="true">1.</strong> About Me</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="work.html"><strong aria-hidden="true">1.1.</strong> Work Experience</a></li><li class="chapter-item expanded "><a href="education.html"><strong aria-hidden="true">1.2.</strong> Education</a></li><li class="chapter-item expanded "><a href="skills.html"><strong aria-hidden="true">1.3.</strong> Skills</a></li></ol></li><li class="chapter-item expanded "><a href="00-blog.html"><strong aria-hidden="true">2.</strong> Python vs Rust</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01-pandas-vs-rust.html" class="active"><strong aria-hidden="true">2.1.</strong> Pandas vs Rust</a></li><li class="chapter-item expanded "><a href="02-polars-vs-rust.html"><strong aria-hidden="true">2.2.</strong> Pandas vs Polars </a></li><li class="chapter-item expanded "><a href="03-deep_learning_in_rust.html"><strong aria-hidden="true">2.3.</strong> Deep Learning in Rust</a></li></ol></li></ol>            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                                                <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                                            </div>

                    <h1 class="menu-title">Haixuan Xavier Tao</h1>

                    <div class="right-buttons">
                                                <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                                                                        
                    </div>
                </div>

                                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="pandas-vs-rust"><a class="header" href="#pandas-vs-rust">Pandas vs Rust</a></h1>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Pandas is the main Data analysis package of Python. For many reasons, Native Python has very poor performance on data analysis without vectorizing with NumPy and the likes. And historically, Pandas has been created by Wes McKinney to package those optimisations in a nice API to facilitate data analysis in Python.</p>
<p>This, however, is not necessary for Rust. Rust has great data performance natively. This is why Rust doesn’t really need a package like Pandas.</p>
<p>I believe the rustiest way to do Data Manipulation in Rust would be to build a <strong>heap of data struct</strong>.</p>
<p><em>But, I could be wrong, let me know if that’s the case.</em></p>
<p>This is my experience and reasoning comparing <strong>Pandas vs Rust</strong>.</p>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<p>Performance benchmarks are done on this very random dataset: <a href="https://www.kaggle.com/START-UMD/gtd">https://www.kaggle.com/START-UMD/gtd</a> that offers around 160,000 lines / 130 columns for a total size of 150Mb. The size of this dataset corresponds to the type of dataset I regularly encounter, that’s why I chose this one. It isn’t the biggest dataset in the world, and, more studies should probably be done on a larger dataset.</p>
<p>The merge will be done with another random dataset: <a href="https://datacatalog.worldbank.org/dataset/world-development-indicators">https://datacatalog.worldbank.org/dataset/world-development-indicators</a>, the <code>WDICountry.csv</code></p>
<hr />
<h2 id="1-reading-and-instantiating-data"><a class="header" href="#1-reading-and-instantiating-data">1. Reading and instantiating Data</a></h2>
<h3 id="pandas"><a class="header" href="#pandas">[Pandas]</a></h3>
<p>Reading and instantiating Data in Pandas is pretty straightforward, and handles by default many data quality problems:</p>
<pre><code>import pandas as pd

path = &quot;/home/peter/Documents/TEST/RUST/terrorism/src/globalterrorismdb_0718dist.csv&quot;
df = pd.read_csv(path)
</code></pre>
<h3 id="rust-reading-csv"><a class="header" href="#rust-reading-csv">[Rust] Reading CSV</a></h3>
<p>For Rust, Managing bad quality data is very very tedious. In this dataset, some fields are empty, some lines are badly formatted, and some are not UTF-8 encoded.</p>
<p>To open the CSV, I used the <code>csv</code> crate but it does not solve all the issues listed above. With well-formatted data, reading can be done like so:</p>
<pre><code>let path = &quot;/home/peter/Documents/TEST/RUST/terrorism/src/foo.csv&quot;
let mut rdr = csv::Reader::from_path(path).unwrap();
</code></pre>
<p>But with bad quality formatting, mine looked like this:</p>
<pre><code>use std::fs::File;    
use encoding_rs::WINDOWS_1252;
use encoding_rs_io::DecodeReaderBytesBuilder;

// ...

    let file = File::open(path)?;
    let transcoded = DecodeReaderBytesBuilder::new()
        .encoding(Some(WINDOWS_1252))
        .build(file);
    let mut rdr = csv::ReaderBuilder::new()
        .delimiter(b',')
        .from_reader(transcoded); 
</code></pre>
<p><em>ref:</em> <a href="https://stackoverflow.com/questions/53826986/how-to-read-a-non-utf8-encoded-csv-file"><em>https://stackoverflow.com/questions/53826986/how-to-read-a-non-utf8-encoded-csv-file</em></a></p>
<h3 id="rust-instantiating-the-data"><a class="header" href="#rust-instantiating-the-data">[Rust] Instantiating the data</a></h3>
<p>To instantiate the data, I used Serde <a href="https://serde.rs/">https://serde.rs/</a> for serializing and deserializing my data.</p>
<p>To use Serde, I needed to make a struct of my data. But, having a struct of my data is great has it makes my code follow a model-based coding paradigm with a well-defined type for each field. It also enables me to implement traits and methods on top of them.</p>
<p>However, the data I wanted to use has 130 columns… And, It seemed that there is no way to generate the definition of the struct automatically.</p>
<p>To avoid doing the definition manually, I had to build my own struct generator:</p>
<pre><code>fn inspect(path: &amp;str) {
    let mut record: Record = HashMap::new();

    let mut rdr = csv::Reader::from_path(path).unwrap();

    for result in rdr.deserialize() {
        match result {
            Ok(rec) =&gt; {
                record = rec;
                break;
            }
            Err(e) =&gt; (),
        };
    }
    // Print Struct
    println!(&quot;#[skip_serializing_none]&quot;);
    println!(&quot;#[derive(Debug, Deserialize, Serialize)]&quot;);
    println!(&quot;struct DataFrame {{&quot;);
    for (key, value) in &amp;record {
        println!(&quot;    #[serialize_always]&quot;);

        match value.parse::&lt;i64&gt;() {
            Ok(n) =&gt; {
                println!(&quot;    {}: Option&lt;i64&gt;,&quot;, key);
                continue;
            }
            Err(e) =&gt; (),
        }
        match value.parse::&lt;f64&gt;() {
            Ok(n) =&gt; {
                println!(&quot;    {}: Option&lt;f64&gt;,&quot;, key);
                continue;
            }
            Err(e) =&gt; (),
        }
        println!(&quot;    {}: Option&lt;String&gt;,&quot;, key);
    }
    println!(&quot;}}&quot;);
}
</code></pre>
<p>This generated the struct as follows:</p>
<pre><code>use serde::{Deserialize, Serialize};
use serde_with::skip_serializing_none;

#[skip_serializing_none]
#[derive(Debug, Clone, Deserialize, Serialize)]
struct DataFrame {
    #[serialize_always]
    individual: Option&lt;f64&gt;,
    #[serialize_always]
    natlty3_txt: Option&lt;String&gt;,
    #[serialize_always]
    ransom: Option&lt;f64&gt;,
    #[serialize_always]
    related: Option&lt;String&gt;,
    #[serialize_always]
    gsubname: Option&lt;String&gt;,
    #[serialize_always]
    claim2: Option&lt;String&gt;,
    #[serialize_always]

    // ...
</code></pre>
<p><em>skip_serializing_none: Avoid having error on empty fields in the CSV.</em></p>
<p><em>serialize_always: Makes the number of field when writing csv fixed.</em></p>
<p>Now, that I had my struct, I used serde serialization to populate a vector of struct:</p>
<pre><code>    let mut records: Vec&lt;DataFrame&gt; = Vec::new();

    for result in rdr.deserialize() {
        match result {
            Ok(rec) =&gt; {
                records.push(rec);
            }
            Err(e) =&gt; println!(&quot;{}&quot;, e),
        };
    }
</code></pre>
<p>This generated my vector of struct, hooray 🎉</p>
<p>On a general note with Rust, you shouldn’t expect things to work as smoothly as it would with Python.</p>
<h3 id="conclusion"><a class="header" href="#conclusion"><strong>Conclusion</strong></a></h3>
<p>On reading / instantiating data, <strong>Pandas</strong> wins hands down for CSV.</p>
<hr />
<h2 id="2-filtering"><a class="header" href="#2-filtering">2. Filtering</a></h2>
<h3 id="pandas-1"><a class="header" href="#pandas-1">[Pandas]</a></h3>
<p>There are many ways to do filtering in pandas, the most common way for me is as follows:</p>
<pre><code>df = df[df.country_txt == &quot;United States&quot;]
df.to_csv(&quot;python_output.csv&quot;)
</code></pre>
<h3 id="rust"><a class="header" href="#rust">[Rust]</a></h3>
<p>To do filtering in Rust, we can refer to the docs for vector in Rust <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">https://doc.rust-lang.org/std/vec/struct.Vec.html</a></p>
<p>There is a large umbrella of methods for Vector filtering, with many nightly features that are going to be great for data manipulation when they ship. For this use case, I used the <code>retain</code> method has it was fitted my need perfectly:</p>
<pre><code>    records.retain(|x| &amp;x.country_txt.unwrap() == &quot;United States&quot;);
    let mut wtr =
        csv::Writer::from_path(&quot;output_rust_filter.csv&quot;)?;

    for record in &amp;records {
        wtr.serialize(record)?;
    }
</code></pre>
<p><strong>One big difference between Pandas and Rust is that Rust filtering uses Closures (<em>eq. lambda function in python</em>) whereas Pandas filtering uses Pandas API based on columns. This means Rust can make more complex filters compared to Pandas. It also adds in readability in my opinion.</strong></p>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<table><thead><tr><th></th><th>Time(s)</th><th>Mem Usage(Gb)</th></tr></thead><tbody>
<tr><td>Pandas</td><td>3.0s</td><td>2.5Gb</td></tr>
<tr><td>Rust</td><td>1.6s 🔥 -50%</td><td>1.7Gb 🔥 -32%</td></tr>
</tbody></table>
<p>Even though we’re using Pandas API for filtering, we get significantly better performance using Rust.</p>
<h3 id="conclusion-1"><a class="header" href="#conclusion-1"><strong>Conclusion</strong></a></h3>
<p>On Filtering, <strong>Rust</strong> seems to be more capable and faster. 🚅</p>
<hr />
<h2 id="3-group-by"><a class="header" href="#3-group-by">3. Group By</a></h2>
<h3 id="pandas-2"><a class="header" href="#pandas-2">[Pandas]</a></h3>
<p>Group by are a big part of the data reduction pipeline in python, it goes usually as follows:</p>
<pre><code>df = df.groupby(by=&quot;country_txt&quot;, as_index=False).agg(
    {&quot;nkill&quot;: &quot;sum&quot;, &quot;individual&quot;: &quot;mean&quot;, &quot;eventid&quot;: &quot;count&quot;}
)
df.to_csv(&quot;python_output_groupby.csv&quot;)
</code></pre>
<h3 id="rust-1"><a class="header" href="#rust-1">[Rust]</a></h3>
<p>For group by and data reduction, thanks to <a href="https://able.bio/insideoutclub">David Sanders</a>, group by can be done as follows:</p>
<pre><code>use itertools::Itertools;


// ...

#[derive(Debug, Deserialize, Serialize)]
struct GroupBy {
    country: String,
    total_nkill: f64,
    average_individual: f64,
    count: f64,
}

// ... 

    let groups = records
        .into_iter()
        .sorted_unstable_by(|a, b| Ord::cmp(&amp;a.country_txt, &amp;b.country_txt))
        .group_by(|record| record.country_txt.clone())
        .into_iter()
        .map(|(country, group)| {
            let (total_nkill, count, average_individual) = group.into_iter().fold(
                (0., 0., 0.),
                |(total_nkill, count, average_individual), record| {
                    (
                        total_nkill + record.nkill.unwrap_or(0.),
                        count + 1.,
                        average_individual + record.individual.unwrap_or(0.),
                    )
                },
            );
            GroupBy {
                country: country.unwrap(),
                total_nkill,
                average_individual: average_individual / count,
                count,
            }
        })
        .collect::&lt;Vec&lt;_&gt;&gt;();
    let mut wtr =
        csv::Writer::from_path(&quot;output_rust_groupby.csv&quot;)
            .unwrap();

    for group in &amp;groups {
        wtr.serialize(group)?;
    }
</code></pre>
<p>‌</p>
<p>Although this solution is not as elegant as Pandas groupby, it gives a lot of flexibility on the computation of the reduced fields. Again, thanks to Closures.</p>
<p>I think more reduction method other than <code>sum</code> and <code>fold</code> would greatly improve the development experience of map-reduce style operation in rust. We will then probably have equivalent experience between Rust and Pandas.</p>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<table><thead><tr><th></th><th>Time(s)</th><th>Mem(Gb)</th></tr></thead><tbody>
<tr><td>Pandas</td><td>2.78s</td><td>2.5Gb</td></tr>
<tr><td>Rust</td><td>2.0s🔥 -35%</td><td>1.7Gb🔥 -32%</td></tr>
</tbody></table>
<p>‌</p>
<h3 id="conclusion-2"><a class="header" href="#conclusion-2"><strong>Conclusion</strong></a></h3>
<p>Although the performance is better for Rust, I would advise using <strong>Pandas</strong> for map-reduce heavy application, as it seems more appropriate.</p>
<hr />
<h2 id="4-mutation"><a class="header" href="#4-mutation">4. Mutation</a></h2>
<h3 id="pandas-3"><a class="header" href="#pandas-3">[Pandas]</a></h3>
<p>There are many ways to do mutation in Pandas, I usually do the following for performance and functional style:</p>
<pre><code>df[&quot;computed&quot;] = df[&quot;nkill&quot;].map(lambda x: (x - 10) / 2 + x ** 2 / 3)
df.to_csv(&quot;python_output_map.csv&quot;)
</code></pre>
<h3 id="rust-2"><a class="header" href="#rust-2">[Rust]</a></h3>
<p>For mutation, the functional <code>iter</code> of Rust really makes this part a walk in the park:</p>
<pre><code>    records.iter_mut().for_each(|x: &amp;mut DataFrame| {
        let nkill = match &amp;x.nkill {
            Some(nkill) =&gt; nkill,
            None =&gt; &amp;0.,
        };

        x.computed = Some((nkill - 10.) / 2. + nkill * nkill / 3.);
    });

    let mut wtr = csv::Writer::from_path(
        &quot;output_rust_map.csv&quot;,
    )?;
    for record in &amp;records {
        wtr.serialize(record)?;
    }
</code></pre>
<h3 id="performance-2"><a class="header" href="#performance-2">Performance</a></h3>
<table><thead><tr><th></th><th>Time(s)</th><th>Mem(Gb)</th></tr></thead><tbody>
<tr><td>Pandas</td><td>12.82s</td><td>4.7Gb</td></tr>
<tr><td>Rust</td><td>1.58s🔥 -87%</td><td>1.7Gb🔥 -64%</td></tr>
</tbody></table>
<p>This is where the difference really appeared to me. Pandas do not scale for line-by-line custom build lambda functions. Pandas would have been even worst if I had done an operation involving several columns.</p>
<h3 id="conclusion-3"><a class="header" href="#conclusion-3"><strong>Conclusion</strong></a></h3>
<p><strong>Rust</strong> is way better for line-by-line mutation natively.</p>
<hr />
<h2 id="5-merge"><a class="header" href="#5-merge">5. Merge</a></h2>
<h3 id="python"><a class="header" href="#python">[Python]</a></h3>
<p>Merging in python is pretty efficient generally speaking, it goes like this in general:</p>
<pre><code>df_country = pd.read_csv(
    &quot;/home/peter/Documents/TEST/RUST/terrorism/src/WDICountry.csv&quot;
)

df_merge = pd.merge(
    df, df_country, left_on=&quot;country_txt&quot;, right_on=&quot;Short_Name&quot;
)
df_merge.to_csv(&quot;python_output_merge.csv&quot;)
</code></pre>
<h3 id="rust-3"><a class="header" href="#rust-3">[Rust]</a></h3>
<p>For Rust, however, this is a tricky part as, with Struct, merging isn’t really a thing. For me, the rustiest way of doing a merge is by adding a nested field containing the other struct we want to join data with.</p>
<p>I  first created a new struct and a new heap for the new data:</p>
<pre><code>#[skip_serializing_none]
#[derive(Clone, Debug, Deserialize, Serialize)]
struct DataFrameCountry {
    #[serialize_always]
    SNA_price_valuation: Option&lt;String&gt;,
    #[serialize_always]
    IMF_data_dissemination_standard: Option&lt;String&gt;,
    #[serialize_always]
    Latest_industrial_data: Option&lt;String&gt;,
    #[serialize_always]
    System_of_National_Accounts: Option&lt;String&gt;,
    //...

// ...

    let mut records_country: Vec&lt;DataFrameCountry&gt; = Vec::new();
    let file = File::open(path_country)?;
    let transcoded = DecodeReaderBytesBuilder::new()
        .encoding(Some(WINDOWS_1252))
        .build(file);
    let mut rdr = csv::ReaderBuilder::new()
        .delimiter(b',')
        .from_reader(transcoded); 

    for result in rdr.deserialize() {
        match result {
            Ok(rec) =&gt; {
                records_country.push(rec);
            }
            Err(e) =&gt; println!(&quot;{}&quot;, e),
        };
    }
</code></pre>
<p>I then cloned this new struct with the previous struct on a specific field that is unique.</p>
<pre><code>
impl DataFrame {
    fn add_country_ext(&amp;mut self, country: Option&lt;DataFrameCountry&gt;) {
        self.country_merge = Some(country)
    }
}

//...

    for country in records_country {
        records
            .iter_mut()
            .filter(|record| record.country_txt == country.Short_Name)
            .for_each(|x| {
                x.add_country_ext(Some(country.clone()));
            });
    }
    let mut wtr =
        csv::Writer::from_path(&quot;output_rust_join.csv&quot;)
            .unwrap();
    for record in &amp;records {
        wtr.serialize(record)?;
    }
</code></pre>
<p>I cloned the data for convenience and also for better comparability, but a reference can be passed if you can manage it.</p>
<p>And there we go! 🚀</p>
<p>Except, a nested struct is not yet serializable in CSV for Rust -&gt; <a href="https://github.com/BurntSushi/rust-csv/pull/197">https://github.com/BurntSushi/rust-csv/pull/197</a></p>
<p>So I had to adapt it to:</p>
<pre><code>impl DataFrame {
    fn add_country_ext(&amp;mut self, country: Option&lt;DataFrameCountry&gt;) {
        self.country_ext = Some(format!(&quot;{:?}&quot;, country))
    }
}
</code></pre>
<p>But, then, we got a sort of merge! 🚀</p>
<h3 id="performance-3"><a class="header" href="#performance-3">Performance</a></h3>
<table><thead><tr><th></th><th>Time(s)</th><th>Mem(Gb)</th></tr></thead><tbody>
<tr><td>Pandas</td><td>22.47s</td><td>11.8Gb</td></tr>
<tr><td>Rust</td><td>5.48s🔥 -75%</td><td>2.6Gb🔥 -78%</td></tr>
</tbody></table>
<p>‌</p>
<h3 id="conclusion-4"><a class="header" href="#conclusion-4"><strong>Conclusion</strong></a></h3>
<p><strong>Rust</strong> is capable of doing nested structs that are going to be as capable if not more capable than <strong>Pandas</strong> merges. However, it isn’t really a one to one comparison and in this case, it is going to depend on your use case.</p>
<p>‌</p>
<hr />
<h2 id="ending-conclusion"><a class="header" href="#ending-conclusion">Ending conclusion</a></h2>
<p>After this experience, this is my take away.</p>
<ul>
<li>Use Pandas when you can: small CSV(&lt;1M lines), simple operation, data cleaning …</li>
<li>Use Rust when you have: complex operations, memory heavy or time-consuming pipelines, custom build functions, scalable software…</li>
</ul>
<p>That been said, Rust offers impressive flexibility compared to Pandas. Adding the fact that Rust is way more capable of multi-threading than Pandas, I believe that Rust can solve problems Pandas simply cannot.</p>
<p>Additionally, the possibility to run Rust on any platform(Web, Android, or Embedded) also create new opportunities for data manipulation in places inconceivable for Pandas and can provide solutions for yet to be resolved challenges.</p>
<h3 id="performance-4"><a class="header" href="#performance-4">Performance</a></h3>
<p>The performance table gives us an insight as to what to expect from Rust. I believe, the speedup can go from <strong>x2</strong> at the minimum and up to <strong>x50</strong> for large data pipelines. The memory use will have an even greater decrease as memory usage accumulates over time with python.</p>
<h3 id="disclaimer"><a class="header" href="#disclaimer">Disclaimer</a></h3>
<p>In many ways, Pandas can be optimized, but optimisation comes at a cost, whether it is hardware (e.g. Cluster #Dask, GPU #Cudf) or dependency on the reliability and maintenance of those optimisation packages.</p>
<p>What I like about using Native Rust is that it doesn’t rely on additional hardware nor does it depends on additional packages. This solution doesn’t require an additional layer of abstraction, which makes it way more intuitive in many regards.</p>
<p>‌</p>
<p>‌</p>
<p><strong>I wrote a continuation article covering polars a rust dataframe crate in another post:</strong> <a href="https://able.bio/haixuanTao/data-manipulation-polars-vs-rust--3def44c8"><strong>https://able.bio/haixuanTao/data-manipulation-polars-vs-rust--3def44c8</strong></a></p>
<p><strong>with another repo:</strong> <a href="https://github.com/haixuanTao/dataframe-python-rust"><strong>https://github.com/haixuanTao/dataframe-python-rust</strong></a></p>
<hr />
<h2 id="annexe"><a class="header" href="#annexe">Annexe</a></h2>
<h3 id="git-repository"><a class="header" href="#git-repository">Git repository</a></h3>
<p><a href="https://github.com/haixuanTao/Data-Manipulation-Rust-Pandas">https://github.com/haixuanTao/Data-Manipulation-Rust-Pandas</a></p>
<p>‌</p>
<h3 id="data-oriented-design"><a class="header" href="#data-oriented-design">Data-Oriented Design</a></h3>
<p>One other way to handle data in Rust is using a data-oriented design, that translates into building a struct of heap: <a href="https://jamesmcm.github.io/blog/2020/07/25/intro-dod/">https://jamesmcm.github.io/blog/2020/07/25/intro-dod/</a></p>
<p>I first tried to build it this way, but, I did not manage to make it work, as I had to implement a lot of function to make things like filtering work on all columns.</p>
<p>‌</p>
<h3 id="btreemap"><a class="header" href="#btreemap">BTreeMap</a></h3>
<p>One way to optimize for speed for Rust would be to replace the Vector with a Binary tree as the Heap. The filtering will then be done on this Tree, making the filtering faster. This would work if one field can be used as a primary filter.</p>
<p>‌</p>
<p>‌</p>
<p>‌</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                                                    <a rel="prev" href="00-blog.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        
                                                    <a rel="next" href="02-polars-vs-rust.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                                    <a rel="prev" href="00-blog.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                
                                    <a rel="next" href="02-polars-vs-rust.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                            </nav>

        </div>

        
        
        
                <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        
        
                <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        
    </body>
</html>
