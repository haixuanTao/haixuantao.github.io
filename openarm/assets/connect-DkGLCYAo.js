var Ha=Object.defineProperty;var vn=i=>{throw TypeError(i)};var za=(i,e,t)=>e in i?Ha(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t;var o=(i,e,t)=>za(i,typeof e!="symbol"?e+"":e,t),en=(i,e,t)=>e.has(i)||vn("Cannot "+t);var n=(i,e,t)=>(en(i,e,"read from private field"),t?t.call(i):e.get(i)),c=(i,e,t)=>e.has(i)?vn("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(i):e.set(i,t),l=(i,e,t,s)=>(en(i,e,"write to private field"),s?s.call(i,t):e.set(i,t),t),d=(i,e,t)=>(en(i,e,"access private method"),t);var bs=(i,e,t,s)=>({set _(r){l(i,e,r,t)},get _(){return n(i,e,s)}});(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const r of document.querySelectorAll('link[rel="modulepreload"]'))s(r);new MutationObserver(r=>{for(const a of r)if(a.type==="childList")for(const u of a.addedNodes)u.tagName==="LINK"&&u.rel==="modulepreload"&&s(u)}).observe(document,{childList:!0,subtree:!0});function t(r){const a={};return r.integrity&&(a.integrity=r.integrity),r.referrerPolicy&&(a.referrerPolicy=r.referrerPolicy),r.crossOrigin==="use-credentials"?a.credentials="include":r.crossOrigin==="anonymous"?a.credentials="omit":a.credentials="same-origin",a}function s(r){if(r.ep)return;r.ep=!0;const a=t(r);fetch(r.href,a)}})();var kn=Object.prototype.hasOwnProperty;function En(i,e,t){for(t of i.keys())if(qt(t,e))return t}function qt(i,e){var t,s,r;if(i===e)return!0;if(i&&e&&(t=i.constructor)===e.constructor){if(t===Date)return i.getTime()===e.getTime();if(t===RegExp)return i.toString()===e.toString();if(t===Array){if((s=i.length)===e.length)for(;s--&&qt(i[s],e[s]););return s===-1}if(t===Set){if(i.size!==e.size)return!1;for(s of i)if(r=s,r&&typeof r=="object"&&(r=En(e,r),!r)||!e.has(r))return!1;return!0}if(t===Map){if(i.size!==e.size)return!1;for(s of i)if(r=s[0],r&&typeof r=="object"&&(r=En(e,r),!r)||!qt(s[1],e.get(r)))return!1;return!0}if(t===ArrayBuffer)i=new Uint8Array(i),e=new Uint8Array(e);else if(t===DataView){if((s=i.byteLength)===e.byteLength)for(;s--&&i.getInt8(s)===e.getInt8(s););return s===-1}if(ArrayBuffer.isView(i)){if((s=i.byteLength)===e.byteLength)for(;s--&&i[s]===e[s];);return s===-1}if(!t||typeof i=="object"){s=0;for(t in i)if(kn.call(i,t)&&++s&&!kn.call(e,t)||!(t in e)||!qt(i[t],e[t]))return!1;return Object.keys(e).length===s}}return i!==i&&e!==e}const _a={},Xa=typeof _a<"u"&&!1,In=Symbol.for("@moq/signals");var Tn,A,ge,j;Tn=In;const fn=class fn{constructor(e){c(this,A);c(this,ge,new Set);c(this,j,new Set);o(this,Tn,!0);l(this,A,e)}static from(e){return typeof e=="object"&&e!==null&&In in e?e:new fn(e)}get(){return n(this,A)}peek(){return n(this,A)}set(e,t){const s=n(this,A);if(l(this,A,e),t===!1||t===void 0&&s===n(this,A)||n(this,ge).size===0&&n(this,j).size===0)return;const r=n(this,ge),a=n(this,j);l(this,j,new Set),queueMicrotask(()=>{if(t===void 0&&qt(s,n(this,A))){for(const u of a)n(this,j).add(u);return}for(const u of r)try{u(e)}catch(h){console.error("signal subscriber error",h)}for(const u of a)try{u(e)}catch(h){console.error("signal changed error",h)}})}update(e,t=!0){const s=e(n(this,A));this.set(s,t)}mutate(e,t=!0){const s=e(n(this,A));return this.set(n(this,A),t),s}subscribe(e){return n(this,ge).add(e),()=>n(this,ge).delete(e)}changed(e){return n(this,j).add(e),()=>n(this,j).delete(e)}watch(e){const t=this.subscribe(e);return queueMicrotask(()=>e(n(this,A))),t}static async race(...e){const t=[],s=await new Promise(r=>{for(const a of e)t.push(a.changed(r))});for(const r of t)r();return s}};A=new WeakMap,ge=new WeakMap,j=new WeakMap;let E=fn;var un,nt,m,Z,Y,it,at,me,ot,Zt,Yt,ue,ps,Mn;const $t=class $t{constructor(e){c(this,ue);c(this,nt);c(this,m,[]);c(this,Z,[]);c(this,Y,[]);c(this,it);c(this,at,!1);c(this,me);c(this,ot);c(this,Zt);c(this,Yt);l(this,nt,e),l(this,ot,new Promise(t=>{l(this,me,t)})),l(this,Yt,new Promise(t=>{l(this,Zt,t)})),e&&d(this,ue,ps).call(this)}get(e){if(n(this,m)===void 0)return e.peek();const t=e.peek(),s=e.changed(()=>d(this,ue,ps).call(this));return n(this,Z).push(s),t}set(e,t,...s){if(n(this,m)===void 0)return;e.set(t);const r=s[0],a=r===void 0?void 0:r;this.cleanup(()=>e.set(a))}spawn(e){const t=e().catch(s=>{console.error("spawn error",s)});n(this,m)!==void 0&&n(this,Y).push(t)}timer(e,t){if(n(this,m)===void 0)return;let s;s=setTimeout(()=>{s=void 0,e()},t),this.cleanup(()=>s&&clearTimeout(s))}timeout(e,t){if(n(this,m)===void 0)return;const s=new $t(e);let r=setTimeout(()=>{s.close(),r=void 0},t);n(this,m).push(()=>{r&&(clearTimeout(r),s.close())})}animate(e){if(n(this,m)===void 0)return;let t=requestAnimationFrame(s=>{e(s),t=void 0});this.cleanup(()=>{t&&cancelAnimationFrame(t)})}interval(e,t){if(n(this,m)===void 0)return;const s=setInterval(()=>{e()},t);this.cleanup(()=>clearInterval(s))}effect(e){if(n(this,m)===void 0)return;const t=new $t(e);n(this,m).push(()=>t.close())}subscribe(e,t){if(n(this,m)===void 0){t(e.peek());return}this.effect(s=>{const r=s.get(e);t(r)})}event(e,t,s,r){n(this,m)!==void 0&&(e.addEventListener(t,s,r),this.cleanup(()=>e.removeEventListener(t,s,r)))}reload(){d(this,ue,ps).call(this)}cleanup(e){if(n(this,m)===void 0){e();return}n(this,m).push(e)}close(){if(n(this,m)!==void 0){n(this,Zt).call(this),n(this,me).call(this);for(const e of n(this,m))e();l(this,m,void 0);for(const e of n(this,Z))e();n(this,Z).length=0,n(this,Y).length=0}}get closed(){return n(this,Yt)}get cancel(){return n(this,ot)}};un=new WeakMap,nt=new WeakMap,m=new WeakMap,Z=new WeakMap,Y=new WeakMap,it=new WeakMap,at=new WeakMap,me=new WeakMap,ot=new WeakMap,Zt=new WeakMap,Yt=new WeakMap,ue=new WeakSet,ps=function(){n(this,at)||(l(this,at,!0),queueMicrotask(()=>d(this,ue,Mn).call(this).catch(e=>{console.error("effect error",e,n(this,it))})))},Mn=async function(){if(n(this,m)!==void 0){n(this,me).call(this),l(this,ot,new Promise(e=>{l(this,me,e)}));for(const e of n(this,Z))e();n(this,Z).length=0;for(const e of n(this,m))e();if(n(this,m).length=0,n(this,Y).length>0)try{let e;const t=new Promise(s=>{e=setTimeout(()=>{s()},5e3)});await Promise.race([Promise.all(n(this,Y)),t]),e&&clearTimeout(e),n(this,Y).length=0}catch(e){console.error("async effect error",e),n(this,it)&&console.error("stack",n(this,it))}n(this,m)!==void 0&&(l(this,at,!1),n(this,nt)&&n(this,nt).call(this,this))}},c($t,un,new FinalizationRegistry(e=>{console.warn(`Signals was garbage collected without being closed:
${e}`)}));let xn=$t;function fs(...i){return i.join("/").replace(/\/+/g,"/").replace(/^\/+/,"").replace(/\/+$/,"")}function Ka(i,e){return i===""?!0:e.startsWith(i)?e.length===i.length?!0:e[i.length]==="/":!1}function Sn(i,e){return Ka(i,e)?i===""?e:e.length===i.length?"":e.slice(i.length+1):null}function qn(i,e){return i===""?e:e===""?i:`${i}/${e}`}function ys(){return""}class Ja{constructor(){o(this,"queue",new E([]));o(this,"closed",new E(!1))}}class Dn{constructor(e=ys()){o(this,"state",new Ja);o(this,"prefix");o(this,"closed");this.prefix=e,this.closed=new Promise(t=>{const s=this.state.closed.subscribe(r=>{r&&(t(r instanceof Error?r:void 0),s())})})}append(e){if(this.state.closed.peek())throw new Error("announced is closed");this.state.queue.mutate(t=>{t.push(e)})}close(e){this.state.closed.set(e??!0),this.state.queue.mutate(t=>{t.length=0})}async next(){for(;;){const e=this.state.queue.peek().shift();if(e)return e;const t=this.state.closed.peek();if(t instanceof Error)throw t;if(t)return;await E.race(this.state.queue,this.state.closed)}}}class Qa{constructor(){o(this,"frames",new E([]));o(this,"closed",new E(!1));o(this,"total",new E(0))}}let hn=class{constructor(e){o(this,"sequence");o(this,"state",new Qa);o(this,"closed");this.sequence=e,this.closed=new Promise(t=>{const s=this.state.closed.subscribe(r=>{r&&(t(r instanceof Error?r:void 0),s())})})}writeFrame(e){if(this.state.closed.peek())throw new Error("group is closed");this.state.frames.mutate(t=>{t.push(e)}),this.state.total.update(t=>t+1)}writeString(e){this.writeFrame(new TextEncoder().encode(e))}writeJson(e){this.writeString(JSON.stringify(e))}writeBool(e){this.writeFrame(new Uint8Array([e?1:0]))}async readFrame(){for(;;){const t=this.state.frames.peek().shift();if(t)return t;const s=this.state.closed.peek();if(s instanceof Error)throw s;if(s)return;await E.race(this.state.frames,this.state.closed)}}async readFrameSequence(){for(;;){const e=this.state.frames.peek(),t=e.shift();if(t)return{sequence:this.state.total.peek()-e.length-1,data:t};const s=this.state.closed.peek();if(s instanceof Error)throw s;if(s)return;await E.race(this.state.frames,this.state.closed)}}async readString(){const e=await this.readFrame();return e?new TextDecoder().decode(e):void 0}async readJson(){const e=await this.readString();return e?JSON.parse(e):void 0}async readBool(){const e=await this.readFrame();return e?e[0]===1:void 0}close(e){this.state.closed.set(e??!0)}};class Za{constructor(){o(this,"groups",new E([]));o(this,"closed",new E(!1))}}var ve;class Ya{constructor(e){o(this,"name");o(this,"state",new Za);c(this,ve);o(this,"closed");this.name=e,this.closed=new Promise(t=>{const s=this.state.closed.subscribe(r=>{r&&(t(r instanceof Error?r:void 0),s())})})}appendGroup(){if(this.state.closed.peek())throw new Error("track is closed");const e=new hn(n(this,ve)??0);return l(this,ve,e.sequence+1),this.state.groups.mutate(t=>{t.push(e),t.sort((s,r)=>s.sequence-r.sequence)}),e}writeGroup(e){if(this.state.closed.peek())throw new Error("track is closed");if(e.sequence<(n(this,ve)??0)){e.close();return}l(this,ve,e.sequence+1),this.state.groups.mutate(t=>{t.push(e),t.sort((s,r)=>s.sequence-r.sequence)})}writeFrame(e){const t=this.appendGroup();t.writeFrame(e),t.close()}writeString(e){const t=this.appendGroup();t.writeString(e),t.close()}writeJson(e){const t=this.appendGroup();t.writeJson(e),t.close()}writeBool(e){const t=this.appendGroup();t.writeBool(e),t.close()}async nextGroup(){for(;;){const e=this.state.groups.peek();if(e.length>0)return e.shift();const t=this.state.closed.peek();if(t instanceof Error)throw t;if(t)return;await E.race(this.state.groups,this.state.closed)}}async readFrame(){var e;return(e=await this.readFrameSequence())==null?void 0:e.data}async readFrameSequence(){var e;for(;;){const t=this.state.groups.peek();for(;t.length>1;){const h=t[0].state.frames.peek(),w=h.shift();if(w){const g=t[0].state.total.peek()-h.length-1;return{group:t[0].sequence,frame:g,data:w}}(e=t.shift())==null||e.close()}if(t.length===0){const h=this.state.closed.peek();if(h instanceof Error)throw h;if(h)return;await E.race(this.state.groups,this.state.closed);continue}const s=t[0],r=s.state.frames.peek(),a=r.shift();if(a){const h=s.state.total.peek()-r.length-1;return{group:s.sequence,frame:h,data:a}}const u=this.state.closed.peek();if(u instanceof Error)throw u;if(u)return;await E.race(this.state.groups,this.state.closed,s.state.frames)}}async readString(){const e=await this.readFrame();if(e)return new TextDecoder().decode(e)}async readJson(){const e=await this.readString();if(e)return JSON.parse(e)}async readBool(){const e=await this.readFrame();if(e){if(e.byteLength!==1||!(e[0]===0||e[0]===1))throw new Error("invalid bool frame");return e[0]===1}}close(e){this.state.closed.set(e??!0);for(const t of this.state.groups.peek())t.close(e)}}ve=new WeakMap;class eo{constructor(){o(this,"requested",new E([]));o(this,"closed",new E(!1))}}class Fn{constructor(){o(this,"state",new eo);o(this,"closed");this.closed=new Promise(e=>{const t=this.state.closed.subscribe(s=>{s&&(e(s instanceof Error?s:void 0),t())})})}async requested(){for(;;){const e=this.state.requested.peek().pop();if(e)return e;const t=this.state.closed.peek();if(t instanceof Error)throw t;if(t)return;await E.race(this.state.requested,this.state.closed)}}subscribe(e,t){const s=new Ya(e);if(this.state.closed.peek())throw new Error(`broadcast is closed: ${this.state.closed.peek()}`);return this.state.requested.mutate(r=>{r.push({track:s,priority:t}),r.sort((a,u)=>a.priority-u.priority)}),s}close(e){this.state.closed.set(e??!0);for(const{track:t}of this.state.requested.peek())t.close(e);this.state.requested.mutate(t=>{t.length=0})}}const be=class be{constructor(e){o(this,"value");if(e<0n||e>be.MAX)throw new Error(`VarInt value out of range: ${e}`);this.value=e}static from(e){return new be(BigInt(e))}size(){const e=this.value;if(e<2n**6n)return 1;if(e<2n**14n)return 2;if(e<2n**30n)return 4;if(e<2n**62n)return 8;throw new Error("VarInt value too large")}encode(e){const t=this.value,s=this.size();if(e.byteOffset+e.byteLength+s>e.buffer.byteLength)throw new Error("destination buffer too small");const r=new DataView(e.buffer,e.byteOffset+e.byteLength,s);if(s===1)r.setUint8(0,Number(t));else if(s===2)r.setUint16(0,16384|Number(t),!1);else if(s===4)r.setUint32(0,2<<30|Number(t),!1);else if(s===8)r.setBigUint64(0,3n<<62n|t,!1);else throw new Error("VarInt value too large");return new Uint8Array(e.buffer,e.byteOffset,e.byteLength+s)}static decode(e){if(e.byteLength<1)throw new Error("Unexpected end of buffer");const t=new DataView(e.buffer,e.byteOffset),s=t.getUint8(0),r=s>>6;let a,u;switch(r){case 0:a=BigInt(s&63),u=1;break;case 1:if(2>e.length)throw new Error("Unexpected end of buffer");a=BigInt(t.getUint16(0,!1)&16383),u=2;break;case 2:if(4>e.length)throw new Error("Unexpected end of buffer");a=BigInt(t.getUint32(0,!1)&1073741823),u=4;break;case 3:if(8>e.length)throw new Error("Unexpected end of buffer");a=t.getBigUint64(0,!1)&0x3fffffffffffffffn,u=8;break;default:throw new Error("Invalid VarInt tag")}const h=new Uint8Array(e.buffer,e.byteOffset+u,e.byteLength-u);return[new be(a),h]}};o(be,"MAX",(1n<<62n)-1n),o(be,"MAX_SIZE",8);let $=be;const Q={Bi:0,Uni:1};class qe{constructor(e){o(this,"value");this.value=e}static create(e,t,s){let r=e<<2n;return t===Q.Uni&&(r|=0x02n),s&&(r|=0x01n),new qe($.from(r))}get dir(){return(this.value.value&0x02n)!==0n?Q.Uni:Q.Bi}get serverInitiated(){return(this.value.value&0x01n)!==0n}canRecv(e){return this.dir===Q.Uni?this.serverInitiated!==e:!0}canSend(e){return this.dir===Q.Uni?this.serverInitiated===e:!0}}const Gn=4,jn=5,Wn=8,sn=9,Vn=29;function $n(i){switch(i.type){case"stream":{let e=new Uint8Array(new ArrayBuffer(9+i.data.length),0,1);return e[0]=i.fin?sn:Wn,e=i.id.value.encode(e),e=new Uint8Array(e.buffer,e.byteOffset,e.byteLength+i.data.length),e.set(i.data,e.byteLength-i.data.length),e}case"reset_stream":{let e=new Uint8Array(new ArrayBuffer(17),0,1);return e[0]=Gn,e=i.id.value.encode(e),e=i.code.encode(e),e}case"stop_sending":{let e=new Uint8Array(new ArrayBuffer(17),0,1);return e[0]=jn,e=i.id.value.encode(e),e=i.code.encode(e),e}case"connection_close":{const e=new TextEncoder().encode(i.reason);let t=new Uint8Array(new ArrayBuffer(9+e.length),0,1);return t[0]=Vn,t=i.code.encode(t),t=new Uint8Array(t.buffer,t.byteOffset,t.byteLength+e.length),t.set(e,t.byteLength-e.length),t}}}function to(i){if(i.length===0)throw new Error("Invalid frame: empty buffer");const e=i[0];i=i.slice(1);let t;if(e===Gn){[t,i]=$.decode(i);const s=new qe(t);return[t,i]=$.decode(i),{type:"reset_stream",id:s,code:t}}if(e===jn){[t,i]=$.decode(i);const s=new qe(t);return[t,i]=$.decode(i),{type:"stop_sending",id:s,code:t}}if(e===Vn){[t,i]=$.decode(i);const s=t,r=new TextDecoder().decode(i);return{type:"connection_close",code:s,reason:r}}if(e===Wn||e===sn)return[t,i]=$.decode(i),{type:"stream",id:new qe(t),data:i,fin:e===sn};throw new Error(`Invalid frame type: ${e}`)}class so{constructor(){o(this,"incomingHighWaterMark");o(this,"incomingMaxAge");o(this,"maxDatagramSize");o(this,"outgoingHighWaterMark");o(this,"outgoingMaxAge");o(this,"readable");o(this,"writable");this.incomingHighWaterMark=1024,this.incomingMaxAge=null,this.maxDatagramSize=1200,this.outgoingHighWaterMark=1024,this.outgoingMaxAge=null,this.readable=new ReadableStream({}),this.writable=new WritableStream({})}}var U,ee,N,es,I,L,Ns,Ls,ts,ss,ke,Ee,Rs,Hn,f,zn,_n,Xn,Kn,Jn,Qn,Zn,ye,K,gs;const Ts=class Ts{constructor(e,t){c(this,f);c(this,U);c(this,ee,!1);c(this,N);c(this,es);c(this,I,new Map);c(this,L,new Map);c(this,Ns,0n);c(this,Ls,0n);o(this,"ready");c(this,ts);o(this,"closed");c(this,ss);o(this,"incomingBidirectionalStreams");c(this,ke);o(this,"incomingUnidirectionalStreams");c(this,Ee);o(this,"datagrams",new so);var s;if(t!=null&&t.requireUnreliable)throw new Error("not allowed to use WebSocket; requireUnreliable is true");if(t!=null&&t.serverCertificateHashes&&console.warn("serverCertificateHashes is not supported; trying anyway"),e=d(s=Ts,Rs,Hn).call(s,e),l(this,U,new WebSocket(e,["webtransport"])),this.ready=new Promise(r=>{l(this,ts,r)}),this.closed=new Promise(r=>{l(this,ss,r)}),n(this,U).binaryType="arraybuffer",n(this,U).onopen=()=>n(this,ts).call(this),n(this,U).onmessage=r=>d(this,f,zn).call(this,r),n(this,U).onerror=r=>d(this,f,_n).call(this,r),n(this,U).onclose=r=>d(this,f,Xn).call(this,r),this.incomingBidirectionalStreams=new ReadableStream({start:r=>{l(this,ke,r)}}),this.incomingUnidirectionalStreams=new ReadableStream({start:r=>{l(this,Ee,r)}}),!n(this,ke)||!n(this,Ee))throw new Error("ReadableStream didn't call start")}async createBidirectionalStream(){if(await this.ready,n(this,N))throw n(this,es)||new Error("Connection closed");const e=qe.create(bs(this,Ls)._++,Q.Bi,n(this,ee)),t=new WritableStream({start:r=>{n(this,I).set(e.value.value,r)},write:async r=>{await Promise.race([d(this,f,ye).call(this,{type:"stream",id:e,data:r,fin:!1}),this.closed])},abort:r=>{console.warn("abort",r),d(this,f,K).call(this,{type:"reset_stream",id:e,code:$.from(0)}),n(this,I).delete(e.value.value)},close:async()=>{await Promise.race([d(this,f,ye).call(this,{type:"stream",id:e,data:new Uint8Array,fin:!0}),this.closed]),n(this,I).delete(e.value.value)}});return{readable:new ReadableStream({start:r=>{n(this,L).set(e.value.value,r)},cancel:async()=>{d(this,f,K).call(this,{type:"stop_sending",id:e,code:$.from(0)}),n(this,L).delete(e.value.value)}}),writable:t}}async createUnidirectionalStream(){if(await this.ready,n(this,N))throw n(this,N);const e=qe.create(bs(this,Ns)._++,Q.Uni,n(this,ee)),t=this;return new WritableStream({start:r=>{n(t,I).set(e.value.value,r)},async write(r){var a;await Promise.race([d(a=t,f,ye).call(a,{type:"stream",id:e,data:r,fin:!1}),t.closed])},abort(r){var a;console.warn("abort",r),d(a=t,f,K).call(a,{type:"reset_stream",id:e,code:$.from(0)}),n(t,I).delete(e.value.value)},async close(){var r;await Promise.race([d(r=t,f,ye).call(r,{type:"stream",id:e,data:new Uint8Array,fin:!0}),t.closed]),n(t,I).delete(e.value.value)}})}close(e){if(n(this,N))return;const t=(e==null?void 0:e.closeCode)??0,s=(e==null?void 0:e.reason)??"";d(this,f,K).call(this,{type:"connection_close",code:$.from(t),reason:s}),setTimeout(()=>{n(this,U).close()},100),d(this,f,gs).call(this,t,s)}get congestionControl(){return"default"}};U=new WeakMap,ee=new WeakMap,N=new WeakMap,es=new WeakMap,I=new WeakMap,L=new WeakMap,Ns=new WeakMap,Ls=new WeakMap,ts=new WeakMap,ss=new WeakMap,ke=new WeakMap,Ee=new WeakMap,Rs=new WeakSet,Hn=function(e){const t=typeof e=="string"?new URL(e):e;let s=t.protocol;if(s==="https:")s="wss:";else if(s==="http:")s="ws:";else if(s!=="ws:"&&s!=="wss:")throw new Error(`Unsupported protocol: ${s}`);return`${s}//${t.host}${t.pathname}${t.search}`},f=new WeakSet,zn=function(e){if(!(e.data instanceof ArrayBuffer))return;const t=new Uint8Array(e.data);try{const s=to(t);d(this,f,Kn).call(this,s)}catch(s){console.error("Failed to decode frame:",s),this.close({closeCode:1002,reason:"Protocol violation"})}},_n=function(e){n(this,N)||(l(this,N,new Error(`WebSocket error: ${e.type}`)),d(this,f,gs).call(this,1006,"WebSocket error"))},Xn=function(e){n(this,N)||(l(this,N,new Error(`Connection closed: ${e.code} ${e.reason}`)),d(this,f,gs).call(this,e.code,e.reason))},Kn=function(e){if(e.type==="stream")d(this,f,Jn).call(this,e);else if(e.type==="reset_stream")d(this,f,Qn).call(this,e);else if(e.type==="stop_sending")d(this,f,Zn).call(this,e);else if(e.type==="connection_close")l(this,es,new Error(`Connection closed: ${e.code.value}: ${e.reason}`)),n(this,U).close();else{const t=e;throw new Error(`Unknown frame type: ${t}`)}},Jn=async function(e){const t=e.id.value.value;if(!e.id.canRecv(n(this,ee)))throw new Error("Invalid stream ID direction");let s=n(this,L).get(t);if(!s){if(e.id.serverInitiated===n(this,ee))return;if(!e.id.canRecv(n(this,ee)))throw new Error("received write-only stream");const r=new ReadableStream({start:a=>{s=a,n(this,L).set(t,a)},cancel:()=>{d(this,f,K).call(this,{type:"stop_sending",id:e.id,code:$.from(0)}),n(this,L).delete(t)}});if(!s)throw new Error("ReadableStream didn't call start");if(e.id.dir===Q.Bi){const a=new WritableStream({start:u=>{n(this,I).set(t,u)},write:async u=>{await Promise.race([d(this,f,ye).call(this,{type:"stream",id:e.id,data:u,fin:!1}),this.closed])},abort:u=>{console.warn("abort",u),d(this,f,K).call(this,{type:"reset_stream",id:e.id,code:$.from(0)}),n(this,I).delete(t)},close:async()=>{await Promise.race([d(this,f,ye).call(this,{type:"stream",id:e.id,data:new Uint8Array,fin:!0}),this.closed]),n(this,I).delete(t)}});n(this,ke).enqueue({readable:r,writable:a})}else n(this,Ee).enqueue(r)}e.data.byteLength>0&&s.enqueue(e.data),e.fin&&(s.close(),n(this,L).delete(t))},Qn=function(e){const t=e.id.value.value,s=n(this,L).get(t);s&&(s.error(new Error(`RESET_STREAM: ${e.code.value}`)),n(this,L).delete(t))},Zn=function(e){const t=e.id.value.value,s=n(this,I).get(t);s&&(s.error(new Error(`STOP_SENDING: ${e.code.value}`)),n(this,I).delete(t),d(this,f,K).call(this,{type:"reset_stream",id:e.id,code:e.code}))},ye=async function(e){for(;n(this,U).bufferedAmount>64*1024;)await new Promise(s=>setTimeout(s,10));const t=$n(e);n(this,U).send(t)},K=function(e){const t=$n(e);n(this,U).send(t)},gs=function(e,t){n(this,ss).call(this,{closeCode:e,reason:t});try{n(this,ke).close()}catch{}try{n(this,Ee).close()}catch{}for(const s of n(this,I).values())try{s.error(n(this,N))}catch{}for(const s of n(this,L).values())try{s.error(n(this,N))}catch{}n(this,I).clear(),n(this,L).clear()},c(Ts,Rs);let vs=Ts;const Yn=2**6-1,ei=2**14-1,ti=2**30-1,ro=2**31-1,ln=Number.MAX_SAFE_INTEGER,An=1024*1024*64;let ks=class rn{constructor(e){o(this,"reader");o(this,"writer");this.writer=new Ae(e.writable),this.reader=new Qr(e.readable)}static async accept(e){for(;;){const t=e.incomingBidirectionalStreams.getReader(),s=await t.read();return t.releaseLock(),s.done?void 0:new rn(s.value)}}static async open(e,t){return new rn(await e.createBidirectionalStream({sendOrder:t}))}close(){this.writer.close(),this.reader.stop(new Error("cancel"))}abort(e){this.writer.reset(e),this.reader.stop(e)}};var k,rs,te,v,ms,J,G;class Qr{constructor(e,t){c(this,v);c(this,k);c(this,rs);c(this,te);var s;l(this,k,t??new Uint8Array),l(this,rs,e),l(this,te,(s=n(this,rs))==null?void 0:s.getReader())}async read(e){return e===0?new Uint8Array:(await d(this,v,J).call(this,e),d(this,v,G).call(this,e))}async readAll(){for(;await d(this,v,ms).call(this););return d(this,v,G).call(this,n(this,k).byteLength)}async string(){const e=await this.u53(),t=await this.read(e);return new TextDecoder().decode(t)}async bool(){const e=await this.u8();if(e===0)return!1;if(e===1)return!0;throw new Error("invalid bool value")}async u8(){return await d(this,v,J).call(this,1),d(this,v,G).call(this,1)[0]}async u16(){await d(this,v,J).call(this,2);const t=new DataView(n(this,k).buffer,n(this,k).byteOffset,2).getUint16(0);return d(this,v,G).call(this,2),t}async u53(){const e=await this.u62();if(e>ln)throw new Error("value larger than 53-bits; use v62 instead");return Number(e)}async u62(){await d(this,v,J).call(this,1);const e=(n(this,k)[0]&192)>>6;if(e===0){const r=d(this,v,G).call(this,1)[0];return BigInt(r)&0x3fn}if(e===1){await d(this,v,J).call(this,2);const r=d(this,v,G).call(this,2),a=new DataView(r.buffer,r.byteOffset,r.byteLength);return BigInt(a.getUint16(0))&0x3fffn}if(e===2){await d(this,v,J).call(this,4);const r=d(this,v,G).call(this,4),a=new DataView(r.buffer,r.byteOffset,r.byteLength);return BigInt(a.getUint32(0))&0x3fffffffn}await d(this,v,J).call(this,8);const t=d(this,v,G).call(this,8);return new DataView(t.buffer,t.byteOffset,t.byteLength).getBigUint64(0)&0x3fffffffffffffffn}async done(){return n(this,k).byteLength>0?!1:!await d(this,v,ms).call(this)}stop(e){var t;(t=n(this,te))==null||t.cancel(e).catch(()=>{})}get closed(){var e;return((e=n(this,te))==null?void 0:e.closed)??Promise.resolve()}}k=new WeakMap,rs=new WeakMap,te=new WeakMap,v=new WeakSet,ms=async function(){if(!n(this,te))return!1;const e=await n(this,te).read();if(e.done)return!1;if(e.value.byteLength===0)throw new Error("unexpected empty chunk");const t=new Uint8Array(e.value);if(n(this,k).byteLength===0)l(this,k,t);else{const s=new Uint8Array(n(this,k).byteLength+t.byteLength);s.set(n(this,k)),s.set(t,n(this,k).byteLength),l(this,k,s)}return!0},J=async function(e){if(e>An)throw new Error(`read size ${e} exceeds max size ${An}`);for(;n(this,k).byteLength<e;)if(!await d(this,v,ms).call(this))throw new Error("unexpected end of stream")},G=function(e){const t=new Uint8Array(n(this,k).buffer,n(this,k).byteOffset,e);return l(this,k,new Uint8Array(n(this,k).buffer,n(this,k).byteOffset+e,n(this,k).byteLength-e)),t};var se,ns,D;const yn=class yn{constructor(e){c(this,se);c(this,ns);c(this,D);l(this,ns,e),l(this,D,new ArrayBuffer(8)),l(this,se,n(this,ns).getWriter())}async bool(e){await this.write(Es(n(this,D),e?1:0))}async u8(e){await this.write(Es(n(this,D),e))}async u16(e){await this.write(wn(n(this,D),e))}async i32(e){if(Math.abs(e)>ro)throw new Error(`overflow, value larger than 32-bits: ${e.toString()}`);await this.write(no(n(this,D),e))}async u53(e){if(e<0)throw new Error(`underflow, value is negative: ${e.toString()}`);if(e>ln)throw new Error(`overflow, value larger than 53-bits: ${e.toString()}`);await this.write(io(n(this,D),e))}async u62(e){if(e<0)throw new Error(`underflow, value is negative: ${e.toString()}`);await this.write(ao(n(this,D),e))}async write(e){await n(this,se).write(e)}async string(e){const t=new TextEncoder().encode(e);await this.u53(t.byteLength),await this.write(t)}close(){n(this,se).close().catch(()=>{})}get closed(){return n(this,se).closed}reset(e){n(this,se).abort(e).catch(()=>{})}static async open(e){const t=await e.createUnidirectionalStream();return new yn(t)}};se=new WeakMap,ns=new WeakMap,D=new WeakMap;let Ae=yn;function Es(i,e){const t=new Uint8Array(i,0,1);return t[0]=e,t}function wn(i,e){const t=new DataView(i,0,2);return t.setUint16(0,e),new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function no(i,e){const t=new DataView(i,0,4);return t.setInt32(0,e),new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function si(i,e){const t=new DataView(i,0,4);return t.setUint32(0,e),new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function io(i,e){if(e<=Yn)return Es(i,e);if(e<=ei)return wn(i,e|16384);if(e<=ti)return si(i,e|2147483648);if(e<=ln)return ri(i,BigInt(e)|0xc000000000000000n);throw new Error(`overflow, value larger than 53-bits: ${e.toString()}`)}function ao(i,e){return e<Yn?Es(i,Number(e)):e<ei?wn(i,Number(e)|16384):e<=ti?si(i,Number(e)|2147483648):ri(i,BigInt(e)|0xc000000000000000n)}function ri(i,e){const t=new DataView(i,0,8);return t.setBigUint64(0,e),new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}var ct;class ni{constructor(e){c(this,ct);l(this,ct,e.incomingUnidirectionalStreams.getReader())}async next(){const e=await n(this,ct).read();if(!e.done)return new Qr(e.value)}close(){n(this,ct).cancel()}}ct=new WeakMap;function C(i){return i instanceof Error?i:new Error(String(i))}function oo(i){throw new Error(`unreachable: ${i}`)}const co=new Error("request for lock canceled");var uo=function(i,e,t,s){function r(a){return a instanceof t?a:new t(function(u){u(a)})}return new(t||(t=Promise))(function(a,u){function h(y){try{g(s.next(y))}catch(q){u(q)}}function w(y){try{g(s.throw(y))}catch(q){u(q)}}function g(y){y.done?a(y.value):r(y.value).then(h,w)}g((s=s.apply(i,e||[])).next())})};class ho{constructor(e,t=co){this._value=e,this._cancelError=t,this._queue=[],this._weightedWaiters=[]}acquire(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return new Promise((s,r)=>{const a={resolve:s,reject:r,weight:e,priority:t},u=ii(this._queue,h=>t<=h.priority);u===-1&&e<=this._value?this._dispatchItem(a):this._queue.splice(u+1,0,a)})}runExclusive(e){return uo(this,arguments,void 0,function*(t,s=1,r=0){const[a,u]=yield this.acquire(s,r);try{return yield t(a)}finally{u()}})}waitForUnlock(e=1,t=0){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);return this._couldLockImmediately(e,t)?Promise.resolve():new Promise(s=>{this._weightedWaiters[e-1]||(this._weightedWaiters[e-1]=[]),lo(this._weightedWaiters[e-1],{resolve:s,priority:t})})}isLocked(){return this._value<=0}getValue(){return this._value}setValue(e){this._value=e,this._dispatchQueue()}release(e=1){if(e<=0)throw new Error(`invalid weight ${e}: must be positive`);this._value+=e,this._dispatchQueue()}cancel(){this._queue.forEach(e=>e.reject(this._cancelError)),this._queue=[]}_dispatchQueue(){for(this._drainUnlockWaiters();this._queue.length>0&&this._queue[0].weight<=this._value;)this._dispatchItem(this._queue.shift()),this._drainUnlockWaiters()}_dispatchItem(e){const t=this._value;this._value-=e.weight,e.resolve([t,this._newReleaser(e.weight)])}_newReleaser(e){let t=!1;return()=>{t||(t=!0,this.release(e))}}_drainUnlockWaiters(){if(this._queue.length===0)for(let e=this._value;e>0;e--){const t=this._weightedWaiters[e-1];t&&(t.forEach(s=>s.resolve()),this._weightedWaiters[e-1]=[])}else{const e=this._queue[0].priority;for(let t=this._value;t>0;t--){const s=this._weightedWaiters[t-1];if(!s)continue;const r=s.findIndex(a=>a.priority<=e);(r===-1?s:s.splice(0,r)).forEach(a=>a.resolve())}}}_couldLockImmediately(e,t){return(this._queue.length===0||this._queue[0].priority<t)&&e<=this._value}}function lo(i,e){const t=ii(i,s=>e.priority<=s.priority);i.splice(t+1,0,e)}function ii(i,e){for(let t=i.length-1;t>=0;t--)if(e(i[t]))return t;return-1}var wo=function(i,e,t,s){function r(a){return a instanceof t?a:new t(function(u){u(a)})}return new(t||(t=Promise))(function(a,u){function h(y){try{g(s.next(y))}catch(q){u(q)}}function w(y){try{g(s.throw(y))}catch(q){u(q)}}function g(y){y.done?a(y.value):r(y.value).then(h,w)}g((s=s.apply(i,e||[])).next())})};class Un{constructor(e){this._semaphore=new ho(1,e)}acquire(){return wo(this,arguments,void 0,function*(e=0){const[,t]=yield this._semaphore.acquire(1,e);return t})}runExclusive(e,t=0){return this._semaphore.runExclusive(()=>e(),1,t)}isLocked(){return this._semaphore.isLocked()}waitForUnlock(e=0){return this._semaphore.waitForUnlock(1,e)}release(){this._semaphore.isLocked()&&this._semaphore.release()}cancel(){return this._semaphore.cancel()}}async function b(i,e){let t=new Uint8Array;const s=new Ae(new WritableStream({write(r){const a=t.byteLength+r.byteLength;if(a>t.buffer.byteLength){const u=Math.max(a,t.buffer.byteLength*2),h=new ArrayBuffer(u),w=new Uint8Array(h,0,a);w.set(t),w.set(r,t.byteLength),t=w}else t=new Uint8Array(t.buffer,0,a),t.set(r,a-r.byteLength)}}));try{await e(s)}finally{s.close()}if(await s.closed,t.byteLength>65535)throw new Error(`Message too large: ${t.byteLength} bytes (max 65535)`);await i.u16(t.byteLength),await i.write(t)}async function p(i,e){const t=await i.u16(),s=await i.read(t),r=new Qr(void 0,s),a=await e(r);if(!await r.done())throw new Error("Message decoding consumed too few bytes");return a}var Cs,ai,Os,oi;const At=class At{constructor(e,t,s,r,a,u,h,w,g){c(this,Cs);o(this,"requestId");o(this,"trackNamespace");o(this,"trackName");o(this,"subscriberPriority");o(this,"groupOrder");o(this,"startGroup");o(this,"startObject");o(this,"endGroup");o(this,"endObject");this.requestId=e,this.trackNamespace=t,this.trackName=s,this.subscriberPriority=r,this.groupOrder=a,this.startGroup=u,this.startObject=h,this.endGroup=w,this.endObject=g}async encode(e){return b(e,d(this,Cs,ai).bind(this))}static async decode(e){return p(e,d(At,Os,oi))}};Cs=new WeakSet,ai=async function(e){throw new Error("FETCH messages are not supported")},Os=new WeakSet,oi=async function(e){throw new Error("FETCH messages are not supported")},c(At,Os),o(At,"id",22);let Ot=At;var Bs,ci,Ms,di;const Ut=class Ut{constructor(e){c(this,Bs);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,Bs,ci).bind(this))}static async decode(e){return p(e,d(Ut,Ms,di))}};Bs=new WeakSet,ci=async function(e){throw new Error("FETCH_OK messages are not supported")},Ms=new WeakSet,di=async function(e){throw new Error("FETCH_OK messages are not supported")},c(Ut,Ms),o(Ut,"id",24);let Bt=Ut;var Ds,ui,Fs,hi;const Pt=class Pt{constructor(e,t,s){c(this,Ds);o(this,"requestId");o(this,"errorCode");o(this,"reasonPhrase");this.requestId=e,this.errorCode=t,this.reasonPhrase=s}async encode(e){return b(e,d(this,Ds,ui).bind(this))}static async decode(e){return p(e,d(Pt,Fs,hi))}};Ds=new WeakSet,ui=async function(e){throw new Error("FETCH_ERROR messages are not supported")},Fs=new WeakSet,hi=async function(e){throw new Error("FETCH_ERROR messages are not supported")},c(Pt,Fs),o(Pt,"id",25);let Mt=Pt;var Gs,li,js,wi;const Nt=class Nt{constructor(e){c(this,Gs);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,Gs,li).bind(this))}static async decode(e){return p(e,d(Nt,js,wi))}};Gs=new WeakSet,li=async function(e){throw new Error("FETCH_CANCEL messages are not supported")},js=new WeakSet,wi=async function(e){throw new Error("FETCH_CANCEL messages are not supported")},c(Nt,js),o(Nt,"id",23);let Dt=Nt;var Ws,fi,Vs,yi;const Le=class Le{constructor(e){c(this,Ws);o(this,"newSessionUri");this.newSessionUri=e}async encode(e){return b(e,d(this,Ws,fi).bind(this))}static async decode(e){return p(e,d(Le,Vs,yi))}};Ws=new WeakSet,fi=async function(e){await e.string(this.newSessionUri)},Vs=new WeakSet,yi=async function(e){const t=await e.string();return new Le(t)},c(Le,Vs),o(Le,"id",16);let Ft=Le;async function le(i,e){const t=e.split("/");await i.u53(t.length);for(const s of t)await i.string(s)}async function we(i){const e=[],t=await i.u53();for(let s=0;s<t;s++)e.push(await i.string());return fs(...e)}const tn={MaxRequestId:2n,Implementation:7n};class O{constructor(){o(this,"vars");o(this,"bytes");this.vars=new Map,this.bytes=new Map}get size(){return this.vars.size+this.bytes.size}setBytes(e,t){if(e%2n!==1n)throw new Error(`invalid parameter id: ${e.toString()}, must be odd`);this.bytes.set(e,t)}setVarint(e,t){if(e%2n!==0n)throw new Error(`invalid parameter id: ${e.toString()}, must be even`);this.vars.set(e,t)}getBytes(e){if(e%2n!==1n)throw new Error(`invalid parameter id: ${e.toString()}, must be odd`);return this.bytes.get(e)}getVarint(e){if(e%2n!==0n)throw new Error(`invalid parameter id: ${e.toString()}, must be even`);return this.vars.get(e)}removeBytes(e){if(e%2n!==1n)throw new Error(`invalid parameter id: ${e.toString()}, must be odd`);return this.bytes.delete(e)}removeVarint(e){if(e%2n!==0n)throw new Error(`invalid parameter id: ${e.toString()}, must be even`);return this.vars.delete(e)}async encode(e){await e.u53(this.vars.size+this.bytes.size);for(const[t,s]of this.vars)await e.u62(t),await e.u62(s);for(const[t,s]of this.bytes)await e.u62(t),await e.u53(s.length),await e.write(s)}static async decode(e){const t=await e.u53(),s=new O;for(let r=0;r<t;r++){const a=await e.u62();if(a%2n===0n){if(s.vars.has(a))throw new Error(`duplicate parameter id: ${a.toString()}`);const u=await e.u62();s.setVarint(a,u)}else{if(s.bytes.has(a))throw new Error(`duplicate parameter id: ${a.toString()}`);const u=await e.u53(),h=await e.read(u);s.setBytes(a,h)}}return s}}var Hs,bi,zs,pi;const Re=class Re{constructor(e,t,s,r,a,u,h,w){c(this,Hs);o(this,"requestId");o(this,"trackNamespace");o(this,"trackName");o(this,"trackAlias");o(this,"groupOrder");o(this,"contentExists");o(this,"largest");o(this,"forward");this.requestId=e,this.trackNamespace=t,this.trackName=s,this.trackAlias=r,this.groupOrder=a,this.contentExists=u,this.largest=h,this.forward=w}async encode(e){return b(e,d(this,Hs,bi).bind(this))}static async decode(e){return p(e,d(Re,zs,pi))}};Hs=new WeakSet,bi=async function(e){if(await e.u62(this.requestId),await le(e,this.trackNamespace),await e.string(this.trackName),await e.u62(this.trackAlias),await e.u8(this.groupOrder),await e.bool(this.contentExists),this.contentExists!==!!this.largest)throw new Error("contentExists and largest must both be true or false");this.largest&&(await e.u62(this.largest.groupId),await e.u62(this.largest.objectId)),await e.bool(this.forward),await e.u53(0)},zs=new WeakSet,pi=async function(e){const t=await e.u62(),s=await we(e),r=await e.string(),a=await e.u62(),u=await e.u8(),h=await e.bool(),w=h?{groupId:await e.u62(),objectId:await e.u62()}:void 0,g=await e.bool();return await O.decode(e),new Re(t,s,r,a,u,h,w,g)},c(Re,zs),o(Re,"id",29);let Gt=Re;var _s,gi,Xs,mi;const Lt=class Lt{constructor(){c(this,_s)}async encode(e){return b(e,d(this,_s,gi).bind(this))}static async decode(e){return p(e,d(Lt,Xs,mi))}};_s=new WeakSet,gi=async function(e){throw new Error("PUBLISH_OK messages are not supported")},Xs=new WeakSet,mi=async function(e){throw new Error("PUBLISH_OK messages are not supported")},c(Lt,Xs),o(Lt,"id",30);let jt=Lt;var Ks,vi,Js,ki;const Te=class Te{constructor(e,t,s){c(this,Ks);o(this,"requestId");o(this,"errorCode");o(this,"reasonPhrase");this.requestId=e,this.errorCode=t,this.reasonPhrase=s}async encode(e){return b(e,d(this,Ks,vi).bind(this))}static async decode(e){return p(e,d(Te,Js,ki))}};Ks=new WeakSet,vi=async function(e){await e.u62(this.requestId),await e.u62(BigInt(this.errorCode)),await e.string(this.reasonPhrase)},Js=new WeakSet,ki=async function(e){const t=await e.u62(),s=Number(await e.u62()),r=await e.string();return new Te(t,s,r)},c(Te,Js),o(Te,"id",31);let ft=Te;var Qs,Ei,Zs,Ii;const Ce=class Ce{constructor(e,t,s){c(this,Qs);o(this,"requestId");o(this,"statusCode");o(this,"reasonPhrase");this.requestId=e,this.statusCode=t,this.reasonPhrase=s}async encode(e){return b(e,d(this,Qs,Ei).bind(this))}static async decode(e){return p(e,d(Ce,Zs,Ii))}};Qs=new WeakSet,Ei=async function(e){await e.u62(this.requestId),await e.u62(BigInt(this.statusCode)),await e.u62(BigInt(0)),await e.string(this.reasonPhrase)},Zs=new WeakSet,Ii=async function(e){const t=await e.u62(),s=Number(await e.u62());await e.u62();const r=await e.string();return new Ce(t,s,r)},c(Ce,Zs),o(Ce,"id",11);let Ue=Ce;var Ys,xi,er,Si;const Oe=class Oe{constructor(e,t){c(this,Ys);o(this,"requestId");o(this,"trackNamespace");this.requestId=e,this.trackNamespace=t}async encode(e){return b(e,d(this,Ys,xi).bind(this))}static async decode(e){return p(e,d(Oe,er,Si))}};Ys=new WeakSet,xi=async function(e){await e.u62(this.requestId),await le(e,this.trackNamespace),await e.u53(0)},er=new WeakSet,Si=async function(e){const t=await e.u62(),s=await we(e);return await O.decode(e),new Oe(t,s)},c(Oe,er),o(Oe,"id",6);let yt=Oe;var tr,qi,sr,$i;const Be=class Be{constructor(e){c(this,tr);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,tr,qi).bind(this))}static async decode(e){return p(e,d(Be,sr,$i))}};tr=new WeakSet,qi=async function(e){await e.u62(this.requestId)},sr=new WeakSet,$i=async function(e){const t=await e.u62();return new Be(t)},c(Be,sr),o(Be,"id",7);let Wt=Be;var rr,Ai,nr,Ui;const Me=class Me{constructor(e,t,s){c(this,rr);o(this,"requestId");o(this,"errorCode");o(this,"reasonPhrase");this.requestId=e,this.errorCode=t,this.reasonPhrase=s}async encode(e){return b(e,d(this,rr,Ai).bind(this))}static async decode(e){return p(e,d(Me,nr,Ui))}};rr=new WeakSet,Ai=async function(e){await e.u62(this.requestId),await e.u62(BigInt(this.errorCode)),await e.string(this.reasonPhrase)},nr=new WeakSet,Ui=async function(e){const t=await e.u62(),s=Number(await e.u62()),r=await e.string();return new Me(t,s,r)},c(Me,nr),o(Me,"id",8);let Vt=Me;var ir,Pi,ar,Ni;const De=class De{constructor(e,t=0,s=""){c(this,ir);o(this,"trackNamespace");o(this,"errorCode");o(this,"reasonPhrase");this.trackNamespace=e,this.errorCode=t,this.reasonPhrase=s}async encode(e){return b(e,d(this,ir,Pi).bind(this))}static async decode(e){return p(e,d(De,ar,Ni))}};ir=new WeakSet,Pi=async function(e){await le(e,this.trackNamespace),await e.u62(BigInt(this.errorCode)),await e.string(this.reasonPhrase)},ar=new WeakSet,Ni=async function(e){const t=await we(e),s=Number(await e.u62()),r=await e.string();return new De(t,s,r)},c(De,ar),o(De,"id",12);let Ht=De;var or,Li,cr,Ri;const Fe=class Fe{constructor(e){c(this,or);o(this,"trackNamespace");this.trackNamespace=e}async encode(e){return b(e,d(this,or,Li).bind(this))}static async decode(e){return p(e,d(Fe,cr,Ri))}};or=new WeakSet,Li=async function(e){await le(e,this.trackNamespace)},cr=new WeakSet,Ri=async function(e){const t=await we(e);return new Fe(t)},c(Fe,cr),o(Fe,"id",9);let bt=Fe;var dr,Ti,ur,Ci;const Ge=class Ge{constructor(e){c(this,dr);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,dr,Ti).bind(this))}static async decode(e){return p(e,d(Ge,ur,Ci))}};dr=new WeakSet,Ti=async function(e){await e.u62(this.requestId)},ur=new WeakSet,Ci=async function(e){return new Ge(await e.u62())},c(Ge,ur),o(Ge,"id",21);let zt=Ge;var hr,Oi,lr,Bi;const je=class je{constructor(e){c(this,hr);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,hr,Oi).bind(this))}static async decode(e){return p(e,d(je,lr,Bi))}};hr=new WeakSet,Oi=async function(e){await e.u62(this.requestId)},lr=new WeakSet,Bi=async function(e){return new je(await e.u62())},c(je,lr),o(je,"id",26);let _t=je;const fo=128;var wr,Mi,fr,Di;const We=class We{constructor(e,t=new O){c(this,wr);o(this,"versions");o(this,"parameters");this.versions=e,this.parameters=t}async encode(e){return b(e,d(this,wr,Mi).bind(this))}static async decode(e){return p(e,d(We,fr,Di))}};wr=new WeakSet,Mi=async function(e){await e.u53(this.versions.length);for(const t of this.versions)await e.u53(t);await this.parameters.encode(e)},fr=new WeakSet,Di=async function(e){const t=await e.u53();if(t>fo)throw new Error(`too many versions: ${t}`);const s=[];for(let a=0;a<t;a++){const u=await e.u53();s.push(u)}const r=await O.decode(e);return new We(s,r)},c(We,fr),o(We,"id",32);let pt=We;var yr,Fi,br,Gi;const Ve=class Ve{constructor(e,t=new O){c(this,yr);o(this,"version");o(this,"parameters");this.version=e,this.parameters=t}async encode(e){return b(e,d(this,yr,Fi).bind(this))}static async decode(e){return p(e,d(Ve,br,Gi))}};yr=new WeakSet,Fi=async function(e){await e.u53(this.version),await this.parameters.encode(e)},br=new WeakSet,Gi=async function(e){const t=await e.u53(),s=await O.decode(e);return new Ve(t,s)},c(Ve,br),o(Ve,"id",33);let gt=Ve;const ji=2;var z,pr,Wi,gr,Vi;let Is=(z=class{constructor(e,t,s,r){c(this,pr);o(this,"requestId");o(this,"trackNamespace");o(this,"trackName");o(this,"subscriberPriority");this.requestId=e,this.trackNamespace=t,this.trackName=s,this.subscriberPriority=r}async encode(e){return b(e,d(this,pr,Wi).bind(this))}static async decode(e){return p(e,d(z,gr,Vi))}},pr=new WeakSet,Wi=async function(e){await e.u62(this.requestId),await le(e,this.trackNamespace),await e.string(this.trackName),await e.u8(this.subscriberPriority),await e.u8(ji),await e.bool(!0),await e.u53(2),await e.u53(0)},gr=new WeakSet,Vi=async function(e){const t=await e.u62(),s=await we(e),r=await e.string(),a=await e.u8(),u=await e.u8();if(u>2)throw new Error(`unknown group order: ${u}`);const h=await e.bool();if(!h)throw new Error(`unsupported forward value: ${h}`);const w=await e.u53();if(w!==1&&w!==2)throw new Error(`unsupported filter type: ${w}`);return await O.decode(e),new z(t,s,r,a)},c(z,gr),o(z,"id",3),z);var _,mr,Hi,vr,zi;let xs=(_=class{constructor(e,t){c(this,mr);o(this,"requestId");o(this,"trackAlias");this.requestId=e,this.trackAlias=t}async encode(e){return b(e,d(this,mr,Hi).bind(this))}static async decode(e){return p(e,d(_,vr,zi))}},mr=new WeakSet,Hi=async function(e){await e.u62(this.requestId),await e.u62(this.trackAlias),await e.u62(0n),await e.u8(ji),await e.bool(!1),await e.u53(0)},vr=new WeakSet,zi=async function(e){const t=await e.u62(),s=await e.u62(),r=await e.u62();if(r!==BigInt(0))throw new Error(`unsupported expires: ${r}`);return await e.u8(),await e.bool()&&(await e.u62(),await e.u62()),await O.decode(e),new _(t,s)},c(_,vr),o(_,"id",4),_);var kr,_i,Er,Xi;const He=class He{constructor(e,t,s){c(this,kr);o(this,"requestId");o(this,"errorCode");o(this,"reasonPhrase");this.requestId=e,this.errorCode=t,this.reasonPhrase=s}async encode(e){return b(e,d(this,kr,_i).bind(this))}static async decode(e){return p(e,d(He,Er,Xi))}};kr=new WeakSet,_i=async function(e){await e.u62(this.requestId),await e.u62(BigInt(this.errorCode)),await e.string(this.reasonPhrase)},Er=new WeakSet,Xi=async function(e){const t=await e.u62(),s=Number(await e.u62()),r=await e.string();return new He(t,s,r)},c(He,Er),o(He,"id",5);let mt=He;var Ir,Ki,xr,Ji;const ze=class ze{constructor(e){c(this,Ir);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,Ir,Ki).bind(this))}static async decode(e){return p(e,d(ze,xr,Ji))}};Ir=new WeakSet,Ki=async function(e){await e.u62(this.requestId)},xr=new WeakSet,Ji=async function(e){const t=await e.u62();return new ze(t)},c(ze,xr),o(ze,"id",10);let vt=ze;var Sr,Qi,qr,Zi;const _e=class _e{constructor(e,t){c(this,Sr);o(this,"namespace");o(this,"requestId");this.namespace=e,this.requestId=t}async encode(e){return b(e,d(this,Sr,Qi).bind(this))}static async decode(e){return p(e,d(_e,qr,Zi))}};Sr=new WeakSet,Qi=async function(e){await e.u62(this.requestId),await le(e,this.namespace),await e.u53(0)},qr=new WeakSet,Zi=async function(e){const t=await e.u62(),s=await we(e);return await O.decode(e),new _e(s,t)},c(_e,qr),o(_e,"id",17);let kt=_e;var $r,Yi,Ar,ea;const Xe=class Xe{constructor(e){c(this,$r);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,$r,Yi).bind(this))}static async decode(e){return p(e,d(Xe,Ar,ea))}};$r=new WeakSet,Yi=async function(e){await e.u62(this.requestId)},Ar=new WeakSet,ea=async function(e){const t=await e.u62();return new Xe(t)},c(Xe,Ar),o(Xe,"id",18);let Xt=Xe;var Ur,ta,Pr,sa;const Ke=class Ke{constructor(e,t,s){c(this,Ur);o(this,"requestId");o(this,"errorCode");o(this,"reasonPhrase");this.requestId=e,this.errorCode=t,this.reasonPhrase=s}async encode(e){return b(e,d(this,Ur,ta).bind(this))}static async decode(e){return p(e,d(Ke,Pr,sa))}};Ur=new WeakSet,ta=async function(e){await e.u62(this.requestId),await e.u62(BigInt(this.errorCode)),await e.string(this.reasonPhrase)},Pr=new WeakSet,sa=async function(e){const t=await e.u62(),s=Number(await e.u62()),r=await e.string();return new Ke(t,s,r)},c(Ke,Pr),o(Ke,"id",19);let Kt=Ke;var Nr,ra,Lr,na;const Je=class Je{constructor(e){c(this,Nr);o(this,"requestId");this.requestId=e}async encode(e){return b(e,d(this,Nr,ra).bind(this))}static async decode(e){return p(e,d(Je,Lr,na))}};Nr=new WeakSet,ra=async function(e){await e.u62(this.requestId)},Lr=new WeakSet,na=async function(e){const t=await e.u62();return new Je(t)},c(Je,Lr),o(Je,"id",20);let Et=Je;var Rr,ia,Tr,aa;const Qe=class Qe{constructor(e,t){c(this,Rr);o(this,"trackNamespace");o(this,"trackName");this.trackNamespace=e,this.trackName=t}async encode(e){return b(e,d(this,Rr,ia).bind(this))}static async decode(e){return p(e,d(Qe,Tr,aa))}};Rr=new WeakSet,ia=async function(e){await le(e,this.trackNamespace),await e.string(this.trackName)},Tr=new WeakSet,aa=async function(e){const t=await we(e),s=await e.string();return new Qe(t,s)},c(Qe,Tr),o(Qe,"id",13);let Jt=Qe;var Cr,oa,Or,ca;const M=class M{constructor(e,t,s,r,a){c(this,Cr);o(this,"trackNamespace");o(this,"trackName");o(this,"statusCode");o(this,"lastGroupId");o(this,"lastObjectId");this.trackNamespace=e,this.trackName=t,this.statusCode=s,this.lastGroupId=r,this.lastObjectId=a}async encode(e){return b(e,d(this,Cr,oa).bind(this))}static async decode(e){return p(e,d(M,Or,ca))}};Cr=new WeakSet,oa=async function(e){await le(e,this.trackNamespace),await e.string(this.trackName),await e.u62(BigInt(this.statusCode)),await e.u62(this.lastGroupId),await e.u62(this.lastObjectId)},Or=new WeakSet,ca=async function(e){const t=await we(e),s=await e.string(),r=Number(await e.u62()),a=await e.u62(),u=await e.u62();return new M(t,s,r,a,u)},c(M,Or),o(M,"id",14),o(M,"STATUS_IN_PROGRESS",0),o(M,"STATUS_NOT_FOUND",1),o(M,"STATUS_NOT_AUTHORIZED",2),o(M,"STATUS_ENDED",3);let Pe=M;const Pn={[pt.id]:pt,[gt.id]:gt,[Is.id]:Is,[xs.id]:xs,[mt.id]:mt,[yt.id]:yt,[Wt.id]:Wt,[Vt.id]:Vt,[bt.id]:bt,[vt.id]:vt,[Ue.id]:Ue,[Ht.id]:Ht,[Jt.id]:Jt,[Pe.id]:Pe,[Ft.id]:Ft,[Ot.id]:Ot,[Dt.id]:Dt,[Bt.id]:Bt,[Mt.id]:Mt,[kt.id]:kt,[Xt.id]:Xt,[Kt.id]:Kt,[Et.id]:Et,[Gt.id]:Gt,[jt.id]:jt,[ft.id]:ft,[zt.id]:zt,[_t.id]:_t};var is,re,ne,Ie,Br,Mr;class yo{constructor(e,t){o(this,"stream");c(this,is,0n);c(this,re);c(this,ne);c(this,Ie);c(this,Br,new Un);c(this,Mr,new Un);this.stream=e,l(this,re,t),l(this,ne,new Promise(s=>{l(this,Ie,s)}))}async write(e){console.debug("message write",e),await n(this,Br).runExclusive(async()=>{await this.stream.writer.u53(e.constructor.id),await e.encode(this.stream.writer)})}async read(){return await n(this,Mr).runExclusive(async()=>{const e=await this.stream.reader.u53();if(!(e in Pn))throw new Error(`Unknown control message type: ${e}`);try{const t=await Pn[e].decode(this.stream.reader);return console.debug("message read",t),t}catch(t){throw console.error("failed to decode message",e,t),t}})}maxRequestId(e){if(e<=n(this,re))throw new Error(`max request id must be greater than current max request id: max=${e} current=${n(this,re)}`);l(this,re,e),n(this,Ie).call(this),l(this,ne,new Promise(t=>{l(this,Ie,t)}))}async nextRequestId(){for(;;){const e=n(this,is);if(e<n(this,re))return l(this,is,n(this,is)+2n),e;if(!n(this,ne))return;console.warn("blocked on max request id"),await n(this,ne)}}close(){n(this,Ie).call(this),l(this,ne,void 0)}}is=new WeakMap,re=new WeakMap,ne=new WeakMap,Ie=new WeakMap,Br=new WeakMap,Mr=new WeakMap;const Nn=3;let da=class ua{constructor(e,t,s,r,a){o(this,"flags");o(this,"trackAlias");o(this,"groupId");o(this,"subGroupId");o(this,"publisherPriority");this.flags=a,this.trackAlias=e,this.groupId=t,this.subGroupId=s,this.publisherPriority=r}async encode(e){if(!this.flags.hasSubgroup&&this.subGroupId!==0)throw new Error(`Subgroup ID must be 0 if hasSubgroup is false: ${this.subGroupId}`);let t=16;this.flags.hasExtensions&&(t|=1),this.flags.hasSubgroupObject&&(t|=2),this.flags.hasSubgroup&&(t|=4),this.flags.hasEnd&&(t|=8),await e.u53(t),await e.u62(this.trackAlias),await e.u53(this.groupId),this.flags.hasSubgroup&&await e.u53(this.subGroupId),await e.u8(0)}static async decode(e){const t=await e.u53();if(t<16||t>31)throw new Error(`Unsupported group type: ${t}`);const s={hasExtensions:(t&1)!==0,hasSubgroupObject:(t&2)!==0,hasSubgroup:(t&4)!==0,hasEnd:(t&8)!==0},r=await e.u62(),a=await e.u53(),u=s.hasSubgroup?await e.u53():0,h=await e.u8();return new ua(r,a,u,h,s)}};class rt{constructor(e){o(this,"payload");this.payload=e}async encode(e,t){await e.u53(0),t.hasExtensions&&await e.u53(0),this.payload!==void 0?(await e.u53(this.payload.byteLength),this.payload.byteLength===0?await e.u53(0):await e.write(this.payload)):(await e.u53(0),await e.u53(Nn))}static async decode(e,t){const s=await e.u53();if(s!==0&&console.warn(`object ID delta is not supported, ignoring: ${s}`),t.hasExtensions){const u=await e.u53();await e.read(u)}const r=await e.u53();if(r>0){const u=await e.read(r);return new rt(u)}const a=await e.u53();if(t.hasEnd){if(a===0)return new rt(new Uint8Array(0))}else if(a===0||a===Nn)return new rt;throw new Error(`Unsupported object status: ${a}`)}}var as,T,dt,he,ha,la,wa,Cn;let bo=(Cn=class{constructor(e,t){c(this,he);c(this,as);c(this,T);c(this,dt,new Map);l(this,as,e),l(this,T,t)}publish(e,t){n(this,dt).set(e,t),d(this,he,ha).call(this,e,t)}async handleSubscribe(e){const t=e.trackNamespace,s=n(this,dt).get(t);if(!s){const u=new mt(e.requestId,404,"Broadcast not found");await n(this,T).write(u);return}const r=s.subscribe(e.trackName,e.subscriberPriority),a=new xs(e.requestId,e.requestId);await n(this,T).write(a),console.debug(`publish ok: broadcast=${t} track=${r.name}`),d(this,he,la).call(this,e.requestId,t,r)}async handleTrackStatusRequest(e){const t=new Pe(e.trackNamespace,e.trackName,Pe.STATUS_NOT_FOUND,0n,0n);await n(this,T).write(t)}async handleUnsubscribe(e){}async handlePublishNamespaceOk(e){}async handlePublishNamespaceError(e){}async handlePublishNamespaceCancel(e){}async handleSubscribeNamespace(e){}async handleUnsubscribeNamespace(e){}},as=new WeakMap,T=new WeakMap,dt=new WeakMap,he=new WeakSet,ha=async function(e,t){try{const s=await n(this,T).nextRequestId();if(s===void 0)return;const r=new yt(s,e);await n(this,T).write(r),await t.closed;const a=new bt(e);await n(this,T).write(a)}catch(s){const r=C(s);console.warn(`announce failed: broadcast=${e} error=${r.message}`)}finally{t.close(),n(this,dt).delete(e)}},la=async function(e,t,s){try{for(;;){const a=await s.nextGroup();if(!a)break;d(this,he,wa).call(this,e,a)}console.debug(`publish done: broadcast=${t} track=${s.name}`);const r=new Ue(e,200,"OK");await n(this,T).write(r)}catch(r){const a=C(r);console.warn(`publish error: broadcast=${t} track=${s.name} error=${a.message}`);const u=new Ue(e,500,a.message);await n(this,T).write(u)}finally{s.close()}},wa=async function(e,t){try{const s=await Ae.open(n(this,as)),r=new da(e,t.sequence,0,0,{hasExtensions:!1,hasSubgroup:!1,hasSubgroupObject:!1,hasEnd:!0});console.debug("sending group header",r),await r.encode(s);try{for(;;){const a=await Promise.race([t.readFrame(),s.closed]);if(!a)break;await new rt(a).encode(s,r.flags)}s.close()}catch(a){s.reset(C(a))}}finally{t.close()}},Cn);var B,ie,xe,ut,Se,ae,It,fa,ya,On;let po=(On=class{constructor(e){c(this,It);c(this,B);c(this,ie,new Set);c(this,xe,new Set);c(this,ut,new Map);c(this,Se,new Map);c(this,ae,new Map);l(this,B,e)}announced(e=ys()){const t=new Dn(e);for(const s of n(this,ie))s.startsWith(e)&&t.append({path:s,active:!0});return n(this,xe).add(t),d(this,It,fa).call(this,t,e).finally(()=>{n(this,xe).delete(t)}),t}consume(e){const t=new Fn;return(async()=>{for(;;){const s=await t.requested();if(!s)break;d(this,It,ya).call(this,e,s)}})(),t}async handleSubscribeOk(e){const t=n(this,ae).get(e.requestId);t?t.resolve(e):console.warn("handleSubscribeOk unknown requestId",e.requestId)}async handleSubscribeError(e){const t=n(this,ae).get(e.requestId);t?t.reject(new Error(`SUBSCRIBE_ERROR: code=${e.errorCode} reason=${e.reasonPhrase}`)):console.warn("handleSubscribeError unknown requestId",e.requestId)}async handleGroup(e,t){const s=new hn(e.groupId);e.subGroupId!==0&&console.warn("subgroup ID is not supported, ignoring");try{let r=n(this,Se).get(e.trackAlias);r===void 0&&(r=e.trackAlias,console.warn("unknown track alias, using request ID"));const a=n(this,ut).get(r);if(!a)throw new Error(`unknown track: trackAlias=${e.trackAlias} requestId=${n(this,Se).get(e.trackAlias)}`);for(a.writeGroup(s);await Promise.race([t.done(),s.closed,a.closed])===!1;){const h=await rt.decode(t,e.flags);if(h.payload===void 0)break;s.writeFrame(h.payload)}s.close()}catch(r){const a=C(r);s.close(a),t.stop(a)}}async handlePublish(e){const t=new ft(e.requestId,500,"publish not supported");await n(this,B).write(t)}async handlePublishDone(e){const t=n(this,ae).get(e.requestId);t&&t.reject(new Error(`PUBLISH_DONE: code=${e.statusCode} reason=${e.reasonPhrase}`))}async handlePublishNamespace(e){if(n(this,ie).has(e.trackNamespace)){console.warn("duplicate PUBLISH_NAMESPACE message");return}n(this,ie).add(e.trackNamespace),console.debug(`announced: broadcast=${e.trackNamespace} active=true`);for(const t of n(this,xe))t.append({path:e.trackNamespace,active:!0})}async handlePublishNamespaceDone(e){if(!n(this,ie).has(e.trackNamespace)){console.warn("unknown PUBLISH_NAMESPACE_DONE message");return}n(this,ie).delete(e.trackNamespace),console.debug(`announced: broadcast=${e.trackNamespace} active=false`);for(const t of n(this,xe))t.append({path:e.trackNamespace,active:!1})}async handleSubscribeNamespaceOk(e){}async handleSubscribeNamespaceError(e){throw new Error("SUBSCRIBE_NAMESPACE_ERROR messages are not supported")}async handleTrackStatus(e){throw new Error("TRACK_STATUS messages are not supported")}},B=new WeakMap,ie=new WeakMap,xe=new WeakMap,ut=new WeakMap,Se=new WeakMap,ae=new WeakMap,It=new WeakSet,fa=async function(e,t){const s=await n(this,B).nextRequestId();if(s!==void 0)try{n(this,B).write(new kt(t,s)),await e.closed}finally{n(this,B).write(new Et(s))}},ya=async function(e,t){const s=await n(this,B).nextRequestId();if(s===void 0)return;n(this,ut).set(s,t.track),console.debug(`subscribe start: id=${s} broadcast=${e} track=${t.track.name}`);const r=new Is(s,e,t.track.name,t.priority),a=new Promise((u,h)=>{n(this,ae).set(s,{resolve:u,reject:h})});await n(this,B).write(r);try{const u=await a;n(this,Se).set(u.trackAlias,s),console.debug(`subscribe ok: id=${s} broadcast=${e} track=${t.track.name}`);try{await t.track.closed;const h=new vt(s);await n(this,B).write(h),console.debug(`unsubscribe: id=${s} broadcast=${e} track=${t.track.name}`)}finally{n(this,Se).delete(u.trackAlias)}}catch(u){const h=C(u);t.track.close(h),console.warn(`subscribe error: id=${s} broadcast=${e} track=${t.track.name} error=${h.message}`)}finally{n(this,ut).delete(s),n(this,ae).delete(s)}},On);var W,V,R,x,ht,S,ba,pa,ga,ma,va,ka,Ea,Bn;let go=(Bn=class{constructor(e,t,s,r){c(this,S);o(this,"url");c(this,W);c(this,V);c(this,R);c(this,x);c(this,ht,!1);this.url=e,l(this,W,t),l(this,V,new yo(s,r)),n(this,W).closed.finally(()=>{n(this,V).close()}),l(this,R,new bo(n(this,W),n(this,V))),l(this,x,new po(n(this,V))),d(this,S,ba).call(this)}close(){if(!n(this,ht)){l(this,ht,!0);try{n(this,W).close()}catch{}}}publish(e,t){n(this,R).publish(e,t)}announced(e=ys()){return n(this,x).announced(e)}consume(e){return n(this,x).consume(e)}get closed(){return n(this,W).closed.then(()=>{})}},W=new WeakMap,V=new WeakMap,R=new WeakMap,x=new WeakMap,ht=new WeakMap,S=new WeakSet,ba=async function(){const e=d(this,S,pa).call(this),t=d(this,S,ka).call(this);try{await Promise.all([e,t])}catch(s){n(this,ht)||console.error("fatal error running connection",s)}finally{this.close()}},pa=async function(){for(;;)try{const e=await n(this,V).read();if(e instanceof Is)await n(this,R).handleSubscribe(e);else if(e instanceof vt)await n(this,R).handleUnsubscribe(e);else if(e instanceof Jt)await n(this,R).handleTrackStatusRequest(e);else if(e instanceof Wt)await n(this,R).handlePublishNamespaceOk(e);else if(e instanceof Vt)await n(this,R).handlePublishNamespaceError(e);else if(e instanceof Ht)await n(this,R).handlePublishNamespaceCancel(e);else if(e instanceof yt)await n(this,x).handlePublishNamespace(e);else if(e instanceof bt)await n(this,x).handlePublishNamespaceDone(e);else if(e instanceof xs)await n(this,x).handleSubscribeOk(e);else if(e instanceof mt)await n(this,x).handleSubscribeError(e);else if(e instanceof Ue)await n(this,x).handlePublishDone(e);else if(e instanceof Pe)await n(this,x).handleTrackStatus(e);else if(e instanceof Ft)await d(this,S,ga).call(this,e);else if(e instanceof pt)await d(this,S,ma).call(this,e);else if(e instanceof gt)await d(this,S,va).call(this,e);else if(e instanceof kt)await n(this,R).handleSubscribeNamespace(e);else if(e instanceof Xt)await n(this,x).handleSubscribeNamespaceOk(e);else if(e instanceof Kt)await n(this,x).handleSubscribeNamespaceError(e);else if(e instanceof Et)await n(this,R).handleUnsubscribeNamespace(e);else if(e instanceof Gt)await n(this,x).handlePublish(e);else{if(e instanceof jt)throw new Error("PUBLISH_OK messages are not supported");if(e instanceof ft)throw new Error("PUBLISH_ERROR messages are not supported");if(e instanceof Ot)throw new Error("FETCH messages are not supported");if(e instanceof Bt)throw new Error("FETCH_OK messages are not supported");if(e instanceof Mt)throw new Error("FETCH_ERROR messages are not supported");if(e instanceof Dt)throw new Error("FETCH_CANCEL messages are not supported");e instanceof zt?n(this,V).maxRequestId(e.requestId):e instanceof _t?console.warn("ignoring REQUESTS_BLOCKED message"):oo(e)}}catch(e){console.error("error processing control message",e);break}console.warn("control stream closed")},ga=async function(e){console.warn(`MOQLITE_INCOMPATIBLE: Received GOAWAY with redirect URI: ${e.newSessionUri}`),this.close()},ma=async function(e){console.error("Unexpected CLIENT_SETUP message received after connection established"),this.close()},va=async function(e){console.error("Unexpected SERVER_SETUP message received after connection established"),this.close()},ka=async function(){const e=new ni(n(this,W));for(;;){const t=await e.next();if(!t)break;d(this,S,Ea).call(this,t).then(()=>{t.stop(new Error("cancel"))}).catch(s=>{t.stop(s)})}},Ea=async function(e){try{const t=await da.decode(e);console.debug("received group header",t),await n(this,x).handleGroup(t,e)}catch(t){console.error("error processing object stream",t)}},Bn);const Ln={DRAFT_07:4278190087,DRAFT_14:4278190094};async function fe(i,e){let t=new Uint8Array;const s=new Ae(new WritableStream({write(r){const a=t.byteLength+r.byteLength;if(a>t.buffer.byteLength){const u=Math.max(a,t.buffer.byteLength*2),h=new ArrayBuffer(u),w=new Uint8Array(h,0,a);w.set(t),w.set(r,t.byteLength),t=w}else t=new Uint8Array(t.buffer,0,a),t.set(r,a-r.byteLength)}}));await e(s),s.close(),await s.closed,await i.u53(t.byteLength),await i.write(t)}async function X(i,e){const t=await i.u53(),s=await i.read(t),r=new Qr(void 0,s),a=await e(r);if(!await r.done())throw new Error("Message decoding consumed too few bytes");return a}async function Zr(i,e){if(!await i.done())return await X(i,e)}var Dr,Ia,os,nn;const Ze=class Ze{constructor(e,t){c(this,Dr);o(this,"suffix");o(this,"active");this.suffix=e,this.active=t}async encode(e){return fe(e,d(this,Dr,Ia).bind(this))}static async decode(e){return X(e,d(Ze,os,nn))}static async decodeMaybe(e){return Zr(e,d(Ze,os,nn))}};Dr=new WeakSet,Ia=async function(e){await e.bool(this.active),await e.string(this.suffix)},os=new WeakSet,nn=async function(e){const t=await e.bool(),s=fs(await e.string());return new Ze(s,t)},c(Ze,os);let Qt=Ze;var Fr,xa,Gr,Sa;const Rt=class Rt{constructor(e){c(this,Fr);o(this,"prefix");this.prefix=e}async encode(e){return fe(e,d(this,Fr,xa).bind(this))}static async decode(e){return X(e,d(Rt,Gr,Sa))}};Fr=new WeakSet,xa=async function(e){await e.string(this.prefix)},Gr=new WeakSet,Sa=async function(e){const t=fs(await e.string());return new Rt(t)},c(Rt,Gr);let Ss=Rt;var jr,qa,Wr,$a;const Tt=class Tt{constructor(e){c(this,jr);o(this,"suffixes");this.suffixes=e}async encode(e){return fe(e,d(this,jr,qa).bind(this))}static async decode(e){return X(e,d(Tt,Wr,$a))}};jr=new WeakSet,qa=async function(e){await e.u53(this.suffixes.length);for(const t of this.suffixes)await e.string(t)},Wr=new WeakSet,$a=async function(e){const t=await e.u53(),s=[];for(let r=0;r<t;r++)s.push(fs(await e.string()));return new Tt(s)},c(Tt,Wr);let qs=Tt;var Vr,Aa,cs,an;const Ye=class Ye{constructor(e,t){c(this,Vr);o(this,"subscribe");o(this,"sequence");this.subscribe=e,this.sequence=t}async encode(e){return fe(e,d(this,Vr,Aa).bind(this))}static async decode(e){return X(e,d(Ye,cs,an))}static async decodeMaybe(e){return Zr(e,d(Ye,cs,an))}};Vr=new WeakSet,Aa=async function(e){await e.u62(this.subscribe),await e.u53(this.sequence)},cs=new WeakSet,an=async function(e){return new Ye(await e.u62(),await e.u53())},c(Ye,cs);let $s=Ye;const pe={DRAFT_01:4279086337,DRAFT_02:4279086338};var Hr,Ua,ds,on;const et=class et{constructor(e){c(this,Hr);o(this,"priority");this.priority=e}async encode(e){return fe(e,d(this,Hr,Ua).bind(this))}static async decode(e){return X(e,d(et,ds,on))}static async decodeMaybe(e){return Zr(e,d(et,ds,on))}};Hr=new WeakSet,Ua=async function(e){await e.u8(this.priority)},ds=new WeakSet,on=async function(e){const t=await e.u8();return new et(t)},c(et,ds);let As=et;var zr,Pa,_r,Na;const Ct=class Ct{constructor(e,t,s,r){c(this,zr);o(this,"id");o(this,"broadcast");o(this,"track");o(this,"priority");this.id=e,this.broadcast=t,this.track=s,this.priority=r}async encode(e){return fe(e,d(this,zr,Pa).bind(this))}static async decode(e){return X(e,d(Ct,_r,Na))}};zr=new WeakSet,Pa=async function(e){await e.u62(this.id),await e.string(this.broadcast),await e.string(this.track),await e.u8(this.priority)},_r=new WeakSet,Na=async function(e){const t=await e.u62(),s=fs(await e.string()),r=await e.string(),a=await e.u8();return new Ct(t,s,r,a)},c(Ct,_r);let Us=Ct;var Xr,La,Kr,Ra;const tt=class tt{constructor({version:e,priority:t=void 0}){c(this,Xr);o(this,"version");o(this,"priority");this.version=e,this.priority=t}async encode(e){return fe(e,d(this,Xr,La).bind(this))}static async decode(e,t){return X(e,d(tt,Kr,Ra).bind(tt,t))}};Xr=new WeakSet,La=async function(e){if(this.version!==pe.DRAFT_02)if(this.version===pe.DRAFT_01)await e.u8(this.priority??0);else{const t=this.version;throw new Error(`unsupported version: ${t}`)}},Kr=new WeakSet,Ra=async function(e,t){let s;if(e!==pe.DRAFT_02)if(e===pe.DRAFT_01)s=await t.u8();else{const r=e;throw new Error(`unsupported version: ${r}`)}return new tt({version:e,priority:s})},c(tt,Kr);let Ps=tt;var us,H,xt,Ta,Ca;class mo{constructor(e,t){c(this,xt);o(this,"version");c(this,us);c(this,H,new E(new Map));l(this,us,e),this.version=t}publish(e,t){n(this,H).mutate(s=>{if(!s)throw new Error("closed");s.set(e,t)}),t.closed.finally(()=>{n(this,H).mutate(s=>{s==null||s.delete(e)})})}async runAnnounce(e,t){console.debug(`announce: prefix=${e.prefix}`);let s=new Set;const r=n(this,H).peek();if(!r)return;for(const u of r.keys()){const h=Sn(e.prefix,u);h!==null&&(console.debug(`announce: broadcast=${u} active=true`),s.add(h))}for(await new qs([...s]).encode(t.writer);;){let u;const h=new Promise(y=>{u=n(this,H).changed(y)}),w=await Promise.race([h,t.reader.closed]);if(u(),!w)break;const g=new Set;for(const y of w.keys()){const q=Sn(e.prefix,y);q!==null&&g.add(q)}for(const y of g.difference(s))console.debug(`announce: broadcast=${y} active=true`),await new Qt(y,!0).encode(t.writer);for(const y of s.difference(g))console.debug(`announce: broadcast=${y} active=false`),await new Qt(y,!1).encode(t.writer);s=g}}async runSubscribe(e,t){var a;const s=(a=n(this,H).peek())==null?void 0:a.get(e.broadcast);if(!s){console.debug(`publish unknown: broadcast=${e.broadcast}`),t.writer.reset(new Error("not found"));return}const r=s.subscribe(e.track,e.priority);try{await new Ps({version:this.version,priority:e.priority}).encode(t.writer),console.debug(`publish ok: broadcast=${e.broadcast} track=${r.name}`);const h=d(this,xt,Ta).call(this,e.id,e.broadcast,r,t.writer);for(;;){const w=As.decodeMaybe(t.reader),g=await Promise.any([h,w]);if(!g)break;g instanceof As&&console.warn("subscribe update not supported",g)}console.debug(`publish done: broadcast=${e.broadcast} track=${r.name}`),t.close(),r.close()}catch(u){const h=C(u);console.warn(`publish error: broadcast=${e.broadcast} track=${r.name} error=${h.message}`),r.close(h),t.abort(h)}}close(){n(this,H).update(e=>{for(const t of(e==null?void 0:e.values())??[])t.close()})}}us=new WeakMap,H=new WeakMap,xt=new WeakSet,Ta=async function(e,t,s,r){try{for(;;){const a=s.nextGroup(),u=await Promise.race([a,r.closed]);if(!u){a.then(h=>h==null?void 0:h.close()).catch(()=>{});break}d(this,xt,Ca).call(this,e,u)}console.debug(`publish close: broadcast=${t} track=${s.name}`),s.close(),r.close()}catch(a){const u=C(a);console.warn(`publish error: broadcast=${t} track=${s.name} error=${u.message}`),s.close(u),r.reset(u)}},Ca=async function(e,t){const s=new $s(e,t.sequence);try{const r=await Ae.open(n(this,us));await r.u8(0),await s.encode(r);try{for(;;){const a=await Promise.race([t.readFrame(),r.closed]);if(!a)break;await r.u53(a.byteLength),await r.write(a)}r.close(),t.close()}catch(a){const u=C(a);r.reset(u),t.close(u)}}catch(r){const a=C(r);t.close(a)}};var Jr,Oa,hs,dn;const st=class st{constructor(e){c(this,Jr);o(this,"bitrate");this.bitrate=e}async encode(e){return fe(e,d(this,Jr,Oa).bind(this))}static async decode(e){return X(e,d(st,hs,dn))}static async decodeMaybe(e){return Zr(e,d(st,hs,dn))}};Jr=new WeakSet,Oa=async function(e){await e.u53(this.bitrate)},hs=new WeakSet,dn=async function(e){const t=await e.u53();return new st(t)},c(st,hs);let cn=st;const $e={Session:0,Announce:1,Subscribe:2,ClientCompat:32,ServerCompat:33};var lt,oe,ls,St,Ba,Ma;class vo{constructor(e,t){c(this,St);c(this,lt);o(this,"version");c(this,oe,new Map);c(this,ls,0n);l(this,lt,e),this.version=t}announced(e=ys()){const t=new Dn;return d(this,St,Ba).call(this,t,e),t}consume(e){const t=new Fn;return(async()=>{for(;;){const s=await t.requested();if(!s)break;d(this,St,Ma).call(this,e,s)}})(),t}async runGroup(e,t){const s=n(this,oe).get(e.subscribe);if(!s){if(e.subscribe>=n(this,ls))throw new Error(`unknown subscription: id=${e.subscribe}`);return}const r=new hn(e.sequence);s.writeGroup(r);try{for(;await Promise.race([t.done(),s.closed,r.closed])===!1;){const u=await t.u53(),h=await t.read(u);if(!h)break;r.writeFrame(h)}r.close(),t.stop(new Error("cancel"))}catch(a){const u=C(a);r.close(u),t.stop(u)}}close(){for(const e of n(this,oe).values())e.close();n(this,oe).clear()}}lt=new WeakMap,oe=new WeakMap,ls=new WeakMap,St=new WeakSet,Ba=async function(e,t){console.debug(`announced: prefix=${t}`);const s=new Ss(t);try{const r=await ks.open(n(this,lt));await r.writer.u53($e.Announce),await s.encode(r.writer);const a=await qs.decode(r.reader);for(const u of a.suffixes){const h=qn(t,u);console.debug(`announced: broadcast=${h} active=true`),e.append({path:h,active:!0})}for(;;){const u=await Promise.race([Qt.decodeMaybe(r.reader),e.closed]);if(!u)break;if(u instanceof Error)throw u;const h=qn(t,u.suffix);console.debug(`announced: broadcast=${h} active=${u.active}`),e.append({path:h,active:u.active})}e.close()}catch(r){e.close(C(r))}},Ma=async function(e,t){const s=bs(this,ls)._++;n(this,oe).set(s,t.track),console.debug(`subscribe start: id=${s} broadcast=${e} track=${t.track.name}`);const r=new Us(s,e,t.track.name,t.priority),a=await ks.open(n(this,lt));await a.writer.u53($e.Subscribe),await r.encode(a.writer);try{await Ps.decode(a.reader,this.version),console.debug(`subscribe ok: id=${s} broadcast=${e} track=${t.track.name}`),await Promise.race([a.reader.closed,t.track.closed]),t.track.close(),a.close(),console.debug(`subscribe close: id=${s} broadcast=${e} track=${t.track.name}`)}catch(u){const h=C(u);t.track.close(h),console.warn(`subscribe error: id=${s} broadcast=${e} track=${t.track.name} error=${h.message}`),a.abort(h)}finally{n(this,oe).delete(s)}};var F,ws,ce,de,wt,P,Da,Fa,Ga,ja,Wa,Va;class ko{constructor(e,t,s,r){c(this,P);o(this,"url");o(this,"version");c(this,F);c(this,ws);c(this,ce);c(this,de);c(this,wt,!1);this.url=e,l(this,F,t),l(this,ws,s),this.version=r,l(this,ce,new mo(n(this,F),this.version)),l(this,de,new vo(n(this,F),this.version)),d(this,P,Da).call(this)}close(){if(!n(this,wt)){l(this,wt,!0),n(this,ce).close(),n(this,de).close();try{n(this,F).close()}catch{}}}publish(e,t){n(this,ce).publish(e,t)}announced(e=ys()){return n(this,de).announced(e)}consume(e){return n(this,de).consume(e)}get closed(){return n(this,F).closed.then(()=>{})}}F=new WeakMap,ws=new WeakMap,ce=new WeakMap,de=new WeakMap,wt=new WeakMap,P=new WeakSet,Da=async function(){const e=d(this,P,Fa).call(this),t=d(this,P,Ga).call(this),s=d(this,P,Wa).call(this);try{await Promise.all([e,t,s])}catch(r){n(this,wt)||console.error("fatal error running connection",r)}finally{this.close()}},Fa=async function(){try{for(;await cn.decodeMaybe(n(this,ws).reader););}finally{console.warn("session stream closed")}},Ga=async function(){for(;;){const e=await ks.accept(n(this,F));if(!e)break;d(this,P,ja).call(this,e).catch(t=>{e.writer.reset(t)}).finally(()=>{e.writer.close()})}},ja=async function(e){const t=await e.reader.u53();if(t===$e.Session)throw new Error("duplicate session stream");if(t===$e.Announce){const s=await Ss.decode(e.reader);await n(this,ce).runAnnounce(s,e);return}else if(t===$e.Subscribe){const s=await Us.decode(e.reader);await n(this,ce).runSubscribe(s,e);return}else throw new Error(`unknown stream type: ${t.toString()}`)},Wa=async function(){const e=new ni(n(this,F));for(;;){const t=await e.next();if(!t)break;d(this,P,Va).call(this,t).then(()=>{t.stop(new Error("cancel"))}).catch(s=>{t.stop(s)})}},Va=async function(e){const t=await e.u8();if(t===0){const s=await $s.decode(e);await n(this,de).runGroup(s,e)}else throw new Error(`unknown stream type: ${t.toString()}`)};function Eo(i){if(i=i.startsWith("0x")?i.slice(2):i,i.length%2)throw new Error("invalid hex string length");const e=i.match(/.{2}/g);if(!e)throw new Error("invalid hex string format");return new Uint8Array(e.map(t=>parseInt(t,16)))}const Rn=new Set;async function Po(i,e){var pn,gn,mn;let t;const s=new Promise(Yr=>{t=Yr}),r=globalThis.WebTransport?Io(i,s,e==null?void 0:e.webtransport):void 0,a=!r||Rn.has(i.toString())?0:((pn=e==null?void 0:e.websocket)==null?void 0:pn.delay)??200,u=((gn=e==null?void 0:e.websocket)==null?void 0:gn.enabled)!==!1?xo(((mn=e==null?void 0:e.websocket)==null?void 0:mn.url)??i,a,s):void 0;if(!u&&!r)throw new Error("no transport available; WebTransport not supported and WebSocket is disabled");const h=await Promise.any(r?u?[u,r]:[r]:[u]);if(t&&t(),!h)throw new Error("no transport available");h instanceof vs&&(console.warn(i.toString(),"using WebSocket fallback; the user experience may be degraded"),Rn.add(i.toString()));const w=await ks.open(h);await w.writer.u53($e.ClientCompat);const g=new TextEncoder,y=new O;y.setVarint(tn.MaxRequestId,42069n),y.setBytes(tn.Implementation,g.encode("moq-lite-js"));const q=new pt([pe.DRAFT_02,pe.DRAFT_01,Ln.DRAFT_14],y);console.debug(i.toString(),"sending client setup",q),await q.encode(w.writer);const bn=await w.reader.u53();if(bn!==$e.ServerCompat)throw new Error(`unsupported server message type: ${bn.toString()}`);const Ne=await gt.decode(w.reader);if(console.debug(i.toString(),"received server setup",Ne),Object.values(pe).includes(Ne.version))return console.debug(i.toString(),"moq-lite session established"),new ko(i,h,w,Ne.version);if(Object.values(Ln).includes(Ne.version)){const Yr=Ne.parameters.getVarint(tn.MaxRequestId)??0n;return console.debug(i.toString(),"moq-ietf session established"),new go(i,h,w,Yr)}else throw new Error(`unsupported server version: ${Ne.version.toString()}`)}async function Io(i,e,t){let s=i;const r={allowPooling:!1,congestionControl:"low-latency",...t};if(i.protocol==="http:"){const h=new URL(i);h.pathname="/certificate.sha256",h.search="",console.warn(h.toString(),"performing an insecure fingerprint fetch; use https:// in production");const w=await Promise.race([fetch(h),e]);if(!w)return;const g=await Promise.race([w.text(),e]);if(g===void 0)return;r.serverCertificateHashes=(r.serverCertificateHashes||[]).concat([{algorithm:"sha-256",value:Eo(g)}]),s=new URL(i),s.protocol="https:"}const a=new WebTransport(s,r);if(!await Promise.race([a.ready.then(()=>!0),e])){a.close();return}return a}async function xo(i,e,t){const s=new Promise(h=>setTimeout(h,e));if(!await Promise.race([t,s.then(()=>!0)]))return;e&&console.debug(i.toString(),`no WebTransport after ${e}ms, attempting WebSocket fallback`);const a=new vs(i);if(!await Promise.race([a.ready.then(()=>!0),t])){a.close();return}return a}export{Fn as B,Po as c,fs as f};
